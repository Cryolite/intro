project gmp ;

import alias ;
import errors ;
import feature : feature ;
import make ;
import regex ;
import string ;

path-constant THIS_DIR : . ;


make gmp.download
  : # No sources.
  : @download-gmp
  ;
explicit gmp.download ;

rule download-gmp ( targets * : sources * : properties * )
{
  local ver = [ feature.get-values <gmp-version> : $(properties) ] ;
  URL on $(targets) = http://core.ring.gr.jp/pub/GNU/gmp/gmp-$(ver).tar.bz2 ;
  TARBALL on $(targets) = $(THIS_DIR)/gmp-$(ver).tar.bz2 ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions download-gmp
{
  rm -f "$(<)" || exit $?
  rm -f "$(TARBALL)" || exit $?
  ( cd "$(TARBALL:D)" && wget --quiet --timestamping -- '$(URL)' ) \
    || { echo "ERROR: failed to download the GMP tarball." 2>"$(STDOUT_)" 1>&2; exit 1; }
  [ ! -f "$(TARBALL)" ] && exit 1
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


rule gmp-expand-req ( properties * )
{
  local result = ;
  local ver = [ feature.get-values <gmp-version> : $(properties) ] ;
  if [ path.exists $(THIS_DIR)/gmp-$(ver).tar.gz ]
  {
    result = <source>$(THIS_DIR)/gmp-$(ver).tar.gz ;
  }
  else if [ path.exists $(THIS_DIR)/gmp-$(ver).tar.bz2 ]
  {
    result = <source>$(THIS_DIR)/gmp-$(ver).tar.bz2 ;
  }
  else
  {
    result = <source>gmp.download ;
  }
  return $(result) ;
}

make gmp.expand
  : # Sources are introduced by the indirect conditional requirements.
  : @expand-gmp
  : <conditional>@gmp-expand-req
  ;
explicit gmp.expand ;

rule expand-gmp ( targets * : sources * : properties * )
{
  if $(sources[2])
  {
    errors.error "ERROR: wrong number of sources." ;
  }
  local source = $(sources[1]) ;
  if ! $(source)
  {
    errors.error "ERROR: no source." ;
  }

  local ver = [ feature.get-values <gmp-version> : $(properties) ] ;
  if [ regex.match (gmp-$(ver)\\.tar\\.gz)$ : $(source) : 1 ]
  {
    TARBALL on $(targets) = $(THIS_DIR)/gmp-$(ver).tar.gz ;
    OPTIONS on $(targets) = xzf ;
  }
  else if [ regex.match (gmp-$(ver)\\.tar\\.bz2)$ : $(source) : 1 ]
  {
    TARBALL on $(targets) = $(THIS_DIR)/gmp-$(ver).tar.bz2 ;
    OPTIONS on $(targets) = xjf ;
  }
  else if [ regex.match (gmp.download)$ : $(source) : 1 ]
  {
    TARBALL on $(targets) = $(THIS_DIR)/gmp-$(ver).tar.bz2 ;
    OPTIONS on $(targets) = xjf ;
  }
  else
  {
    errors.error "ERROR: an invalid source." ;
  }

  DEST_DIR on $(targets) = $(THIS_DIR)/gmp-$(ver) ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions expand-gmp
{
  rm -f "$(<)" || exit $?
  rm -rf "$(DEST_DIR)" || exit $?
  [ ! -f "$(>)" ] && exit 1
  [ ! -f "$(TARBALL)" ] && exit 1
  tar $(OPTIONS) "$(TARBALL)" -C "$(TARBALL:D)" \
    || { echo "ERROR: failed to expand the GMP tarball." 2>"$(STDERR_)" 1>&2; exit 1; }
  [ ! -f "$(DEST_DIR)/configure" ] && exit 1
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


rule makefile-req ( properties * )
{
  local results = ;
  local ver = [ feature.get-values <gmp-version> : $(properties) ] ;
  if [ path.exists $(THIS_DIR)/gmp-$(ver)/configure ]
  {
    results += <source>$(THIS_DIR)/gmp-$(ver)/configure ;
  }
  else
  {
    local tmp = <source>gmp.expand ;
    tmp = $(tmp)/<intro-host>unspecified ;
    tmp = $(tmp)/<intro-abi>unspecified ;
    tmp = $(tmp)/<intro-link>unspecified ;
    results += $(tmp) ;
  }
  #errors.error $(results) ;
  return $(results) ;
}

make Makefile
  : # Sources are introduced by the indirect conditional requirements.
  : @configure
  : <conditional>@makefile-req
  ;
explicit Makefile ;

rule configure ( targets * : sources * : properties * )
{
  OPTIONS on $(targets) = ;

  local ver = [ feature.get-values <gmp-version> : $(properties) ] ;

  # Set the path to the 'configure' file.
  local configure = $(THIS_DIR)/gmp-$(ver)/configure ;
  CONFIGURE on $(targets) = $(configure) ;

  # Set the 'build' option for the 'configure' script.
  local build = [ feature.get-values <intro-build> : $(properties) ] ;
  OPTIONS on $(targets) += --build=$(build) ;

  # Set the 'host' option for the 'configure' script.
  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  OPTIONS on $(targets) += --host=$(host) ;

  # Set the 'ABI' option for the 'configure' script.
  local abi = [ feature.get-values <intro-abi> : $(properties) ] ;
  ABI on $(targets) = ;
  if $(abi) != unspecified
  {
    ABI on $(targets) = ABI=$(abi) ;
  }

  # Set the 'prefix' option for the 'configure' script.
  local prefix = [ feature.get-values <intro-prefix> : $(properties) ] ;
  OPTIONS on $(targets) += --prefix=\"$(prefix)\" ;

  # Set the link variants for the 'configure' script.
  local link = [ feature.get-values <intro-link> : $(properties) ] ;
  if $(link) = both || $(link) = static
  {
    OPTIONS on $(targets) += --enable-static ;
  }
  else
  {
    OPTIONS on $(targets) += --disable-static ;
  }
  if $(link) = both || $(link) = shared
  {
    OPTIONS on $(targets) += --enable-shared ;
  }
  else
  {
    OPTIONS on $(targets) += --disable-shared ;
  }

  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions configure
{
  ( cd "$(<:D)" && rm -rf * ) || exit $?
  [ ! -f "$(>)" ] && exit 1
  [ ! -f "$(CONFIGURE)" ] && exit 1
  ( cd "$(<:D)" && $(ABI) "$(CONFIGURE)" $(OPTIONS) 1>"$(STDOUT_)" 2>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'configure' for the GMP build." 2>"$(STDERR_)" 1>&2; exit 1; }
  [ ! -f "$(<)" ] && exit 1
  exit 0
}


make gmp.make
  : Makefile
  : @make-gmp
  ;
explicit gmp.make ;

rule make-gmp ( targets * : sources * : properties * )
{
  CHECK on $(targets) = [ feature.get-values <intro-check> : $(properties) ] ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions make-gmp
{
  rm -f "$(<)" || exit $?
  [ ! -f "$(>)" ] && exit 1
  ( cd "$(<:D)" && make 1>"$(STDOUT_)" 2>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'make' for the GMP build." 2>"$(STDERR_)" 1>&2; exit 1; }
  if [ $(CHECK) = yes ]; then
    ( cd "$(<:D)" && make check 1>"$(STDOUT_)" 2>"$(STDERR_)" ) \
      || { echo "ERROR: failed to 'make check' for the GMP build." 2>"$(STDERR_)" 1>&2; exit 1; }
  fi
  ( cd "$(<:D)" && make install 1>"$(STDOUT_)" 2>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'make install' for the GMP build." 2>"$(STDERR_)" 1>&2; exit 1; }
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


make gmp.test
  : gmp.make
  : @test-gmp
  : # Sources are introduced by the following indirect requirements.
  : <conditional>@test-gmp
  ;
explicit gmp.test ;

rule test-gmp ( targets * : sources * : properties * )
{
  COMMAND on $(targets) = $(THIS_DIR)/test.sh ;
  VERSION on $(targets) = [ feature.get-values <gmp-version> : $(properties) ] ;
  BUILD on $(targets) = [ feature.get-values <intro-build> : $(properties) ] ;
  HOST on $(targets) = [ feature.get-values <intro-host> : $(properties) ] ;
  ABI on $(targets) = [ feature.get-values <intro-abi> : $(properties) ] ;
  PREFIX on $(targets) = [ feature.get-values <intro-prefix> : $(properties) ] ;
  LINK on $(targets) = [ feature.get-values <intro-link> : $(properties) ] ;
  CHECK on $(targets) = [ feature.get-values <intro-check> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions test-gmp
{
  rm -f "$(<)" || exit $?
  x=`"$(COMMAND)" $(VERSION) $(BUILD) $(HOST) $(ABI) "$(PREFIX)" $(LINK) $(CHECK)`
  if [ $? -ne 0 ]; then
    /bin/echo 'ERROR: post-installation test failed for the GMP build.' 2>"$(STDERR_)" 1>&2
    exit 1
  fi
  [ "$x" != 'yes' ] && exit 1
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


rule install-req ( properties * )
{
  local result = <source>gmp.test ;

  local tmp = ;

  local version = [ feature.get-values <gmp-version> : $(properties) ] ;
  if $(version) = current
  {
    tmp = [ string.join [ feature.values <gmp-version> ] : "\\n" ] ;
    version = [ SHELL "/bin/echo -e -n '$(tmp)' | sort --version-sort | tail --lines=2 | head --lines=1 | tr --delete '\n'" ] ;
  }
  result = $(result)/<gmp-version>$(version) ;

  local build = [ feature.get-values <intro-build> : $(properties) ] ;
  tmp = [ SHELL "\"$(THIS_DIR)/config.guess\" | tr --delete '\n'" ] ;
  if $(build) = unspecified
  {
    build = $(tmp) ;
  }
  if $(build) != $(tmp)
  {
    errors.error "ERROR: the given property '<intro-build>$(build)' is not valid." ;
  }
  tmp = [ SHELL "\"$(THIS_DIR)/config.sub\" $(build) | tr --delete '\n'" ] ;
  if $(tmp) != $(build)
  {
    errors.error "ERROR: the given property '<intro-build>$(build)' is not canonical." ;
  }
  result = $(result)/<intro-build>$(build) ;

  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  if $(host) = unspecified
  {
    host = $(build) ;
  }
  tmp = [ SHELL "\"$(THIS_DIR)/config.sub\" $(host) | tr --delete '\n'" ] ;
  if $(tmp) != $(host)
  {
    errors.error "ERROR: the property '<intro-host>$(host)' is not canonical." ;
  }
  result = $(result)/<intro-host>$(host) ;

  local target = [ feature.get-values <intro-target> : $(properties) ] ;
  if ! $(target) = unspecified
  {
    errors.error "ERROR: the property '<intro-target>$(target)' is specified for MPFR build." ;
  }

  local link = [ feature.get-values <intro-link> : $(properties) ] ;
  if $(link) = unspecified
  {
    errors.error "ERROR: '<intro-link>' is not specified for the MPFR build." ;
  }

  local check = [ feature.get-values <intro-check> : $(properties) ] ;
  if $(check) = unspecified
  {
    if $(build) = $(host)
    {
      check = yes ;
    }
    else {
      check = no ;
    }
  }
  result = $(result)/<intro-check>$(check) ;

  #errors.error $(result) ;

  return $(result) ;
}

alias install
  : # The source 'install-normalized' is introduced by the following indirect requirements.
  : <conditional>@install-req
  ;
explicit install ;
