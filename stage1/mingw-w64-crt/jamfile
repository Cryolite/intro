project mingw-w64-crt ;

import alias ;
import errors ;
import feature ;
import make ;
import regex ;


rule gcc-stage1-dep-req ( properties * )
{
  local result ;

  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  if $(stage) = 2 {
    result = <source>../../stage2/gcc//mingw32-stage1.make ;
    # `<intro-stage>2' is automatically propagated.
    # `<intro-host>' is automatically propagated.
    # `<intro-link>unspecified' is automatically propagated.
    # `<intro-multilib>' is automatically propagated.
    # `<intro-multilib-hidden>unspecified' is automatically propagated.
    # `<binutils-version>' is automatically propagated.
    # `<binutils-version-hidden>unspecified' is automatically propagated.
    local gmp-version = [ feature.get-values <gmp-version-hidden> : $(properties) ] ;
    result = $(result)/<gmp-version>$(gmp-version) ;
    result = $(result)/<gmp-version-hidden>unspecified ;
    local mpfr-version = [ feature.get-values <mpfr-version-hidden> : $(properties) ] ;
    result = $(result)/<mpfr-version>$(mpfr-version) ;
    result = $(result)/<mpfr-version-hidden>unspecified ;
    local mpc-version = [ feature.get-values <mpc-version-hidden> : $(properties) ] ;
    result = $(result)/<mpc-version>$(mpc-version) ;
    result = $(result)/<mpc-version-hidden>unspecified ;
    # `<gcc-version>' is automatically propagated.
    # `<gcc-default>yes' is automatically propagated.
  }
  return $(result) ;
}

alias gcc-stage1-dep : : <conditional>@gcc-stage1-dep-req ;
explicit gcc-stage1-dep ;


rule gcc-dep-req ( properties * )
{
  local result ;

  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  if $(stage) = 3 {
    result = <source>../../stage2/gcc//mingw32-stage1.make ;
    result = $(result)/<intro-stage>2 ;
    # `<intro-host>' is automatically propagated.
    # `<intro-link>unspecified' is automatically propagated.
    # `<intro-multilib>' is automatically propagated.
    # `<intro-multilib-hidden>unspecified' is automatically propagated.
    # `<binutils-version>' is automatically propagated.
    # `<binutils-version-hidden>unspecified' is automatically propagated.
    local gmp-version = [ feature.get-values <gmp-version-hidden> : $(properties) ] ;
    result = $(result)/<gmp-version>$(gmp-version) ;
    result = $(result)/<gmp-version-hidden>unspecified ;
    local mpfr-version = [ feature.get-values <mpfr-version-hidden> : $(properties) ] ;
    result = $(result)/<mpfr-version>$(mpfr-version) ;
    result = $(result)/<mpfr-version-hidden>unspecified ;
    local mpc-version = [ feature.get-values <mpc-version-hidden> : $(properties) ] ;
    result = $(result)/<mpc-version>$(mpc-version) ;
    result = $(result)/<mpc-version-hidden>unspecified ;
    # `<gcc-version>' is automatically propagated.
    result = $(result)/<gcc-default>yes ;
  }
  return $(result) ;
}

alias gcc-dep : : <conditional>@gcc-dep-req ;
explicit gcc-dep ;


make make : gcc-stage1-dep gcc-dep : @make-mingw-w64-crt ;
explicit make ;

rule make-mingw-w64-crt ( targets * : sources * : properties * )
{
  OPTIONS on $(targets) = ;

  # Set the path to the 'configure' file.
  local configure = $(INTRO_ROOT_DIR)/mingw-w64-v1.0-20101003/mingw-w64-crt/configure ;
  CONFIGURE on $(targets) = $(configure) ;

  # Set the '--build' and '--host' options for the 'configure' script.
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local build = [ SHELL "\"$(INTRO_ROOT_DIR)/stage1/gcc/config.guess\" | tr --delete '\n'" ] ;
  if $(stage) = 1 {
    errors.error "ERROR: internal error." ;
  }
  else if $(stage) = 2 {
    OPTIONS on $(targets) += --build=$(build) ;
    OPTIONS on $(targets) += --host=$(HOST) ;
  }
  else {
    OPTIONS on $(targets) += --build=$(build) ;
    OPTIONS on $(targets) += --host=$(HOST) ;
  }

  # Set the '--prefix' option for the 'configure' script.
  if $(stage) = 1 {
    errors.error "ERROR: internal error." ;
  }
  else if $(stage) = 2 {
    OPTIONS on $(targets) += --prefix=\"$(PREFIX)\" ;
  }
  else {
    OPTIONS on $(targets) += --prefix=\"$(CROSS_PREFIX)\" ;
  }

  if $(HOST) = x86_64-w64-mingw32 {
    OPTIONS on $(targets) += --enable-lib64 ;
    local multilib = [ feature.get-values <intro-multilib> : $(properties) ] ;
    if $(multilib) = yes {
      OPTIONS on $(targets) += --enable-lib32 ;
    }
  }
  else {
    OPTIONS on $(targets) += --enable-lib32 ;
  }

  if $(stage) = 1 {
    errors.error "ERROR: internal error." ;
  }
  else if $(stage) = 2 {
    OPTIONS on $(targets) += --with-sysroot=\"$(PREFIX)\" ;
  }
  else {
    OPTIONS on $(targets) += --with-sysroot=\"$(CROSS_PREFIX)\" ;
  }

  SET_RUN_VARS on $(targets) = ;
  UNSET_RUN_VARS on $(targets) = ;
  if $(stage) = 1 {
    errors.error "ERROR: internal error." ;
  }
  else {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
    }
    else {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
    }
  }
}
actions make-mingw-w64-crt
{
  rm -f "$(<)" || exit $?
  [ -x "$(CONFIGURE)" ] || exit 1
  { mkdir -p "$(<:D)/build" && ( cd "$(<:D)/build" && rm -rf * ); } || exit $?
  $(SET_RUN_VARS)
  ( cd "$(<:D)/build" && "$(CONFIGURE)" $(OPTIONS) 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    echo "ERROR: failed to 'configure' for the mingw-w64-crt build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  [ -f "$(<:D)/build/Makefile" ] || { $(UNSET_RUN_VARS); exit 1; }
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    echo "ERROR: failed to 'make' for the mingw-w64-crt build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  if [ $(HOST_RUNNABLE) = yes ]; then
    ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) check 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
    if [ $? -ne 0 ]; then
      $(UNSET_RUN_VARS)
      echo "ERROR: failed to 'make check' for the mingw-w64-crt build." 2>>"$(STDERR_)" 1>&2
      exit 1
    fi
  fi
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) install 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    echo "ERROR: failed to 'make install' for the mingw-w64-crt build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  $(UNSET_RUN_VARS)
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


rule install-req ( properties * )
{
  local result = <source>make ;

  local tmp ;

  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  if $(stage) = 1 {
    errors.error "ERROR: '<intro-stage>1' is not valid for the mingw-w64-crt build." ;
  }

  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  if $(host) = unspecified {
    errors.error "ERROR: '<intro-host>' is not specified for the mingw-w64-crt build." ;
  }

  local link = [ feature.get-values <intro-link> : $(properties) ] ;
  if $(link) != unspecified {
    errors.error "ERROR: '<intro-link>$(link)' is not valid for the mingw-w64-crt build." ;
  }

  local multilib = [ feature.get-values <intro-multilib> : $(properties) ] ;
  if $(multilib) = unspecified {
    errors.error "ERROR: '<intro-multilib>' is not specified for the mingw-w64-crt build." ;
  }
  multilib = [ feature.get-values <intro-multilib-hidden> : $(properties) ] ;
  if $(multilib) != unspecified {
    errors.error "ERROR: '<intro-multilib-hidden>$(multilib)' is not valid for the mingw-w64-crt build." ;
  }

  local binutils-version = [ feature.get-values <binutils-version> : $(properties) ] ;
  if $(binutils-version) = unspecified {
    errors.error "ERROR: '<binutils-version>' is not specified for the mingw-w64-crt build." ;
  }
  binutils-version = [ feature.get-values <binutils-version-hidden> : $(properties) ] ;
  if $(binutils-version) != unspecified {
    errors.error "ERROR: '<binutils-version-hidden>$(binutils-version)' is not valid for the mingw-w64-crt build." ;
  }

  local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
  if $(gmp-version) != unspecified {
    errors.error "ERROR: '<gmp-version>$(gmp-version)' is not valid for the mingw-w64-crt build." ;
  }
  gmp-version = [ feature.get-values <gmp-version-hidden> : $(properties) ] ;
  if $(gmp-version) = unspecified {
    errors.error "ERROR: '<gmp-version-hidden>' is not specified for the mingw-w64-crt build." ;
  }

  local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
  if $(mpfr-version) != unspecified {
    errors.error "ERROR: '<mpfr-version>$(mpfr-version)' is not valid for the mingw-w64-crt build." ;
  }
  mpfr-version = [ feature.get-values <mpfr-version-hidden> : $(properties) ] ;
  if $(mpfr-version) = unspecified {
    errors.error "ERROR: '<mpfr-version-hidden>' is not specified for the mingw-w64-crt build." ;
  }

  local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
  if $(mpc-version) != unspecified {
    errors.error "ERROR: '<mpc-version>$(mpc-version)' is not valid for the mingw-w64-crt build." ;
  }
  mpc-version = [ feature.get-values <mpc-version-hidden> : $(properties) ] ;
  if $(mpc-version) = unspecified {
    errors.error "ERROR: '<mpc-version-hidden>' is not specified for the mingw-w64-crt build." ;
  }

  local gcc-version = [ feature.get-values <gcc-version> : $(properties) ] ;
  if $(gcc-version) = unspecified {
    errors.error "ERROR: '<gcc-version>' is not specified for the mingw-w64-crt build." ;
  }

  local gcc-default = [ feature.get-values <gcc-default> : $(properties) ] ;
  if $(stage) = 2 && $(gcc-default) != yes {
    errors.error "ERROR: '<gcc-default>$(gcc-default)' is not valid for the mingw-w64-crt stage 2 build." ;
  }
  if $(stage) = 3 && $(gcc-default) != unspecified {
    errors.error "ERROR: '<gcc-default>$(gcc-default)' is not valid for the mingw-w64-crt stage 3 build." ;
  }

  return $(result) ;
}

alias install : : <conditional>@install-req ;
explicit install ;
