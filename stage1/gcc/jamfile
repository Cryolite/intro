project gcc ;

import alias ;
import errors ;
import feature ;
import make ;
import path ;
import regex ;


rule binutils-dep-req ( properties * )
{
  local result ;
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local enable-cross-binutils = [ feature.get-values <enable-cross-binutils> : $(properties) ] ;
  if $(stage) = 1 {
    # Do nothing.
  }
  else if $(stage) = 2 {
    if $(enable-cross-binutils) = yes {
      result = <source>../../stage2/binutils//install ;
      # `<intro-stage>2' is automatically propagated.
      # `<intro-host>' is automatically propagated.
      # `<intro-link>unspecified' is automatically propagated.
      # `<intro-multilib>' is automatically propagated.
      # `<intro-multilib-hidden>unspecified' is automatically propagated.
      # `<binutils-version>' is automatically propagated.
      # `<binutils-version-hidden>unspecified' is automatically propagated.
      result = $(result)/<gmp-version>unspecified ;
      # `<gmp-version-hidden>unspecified' is automatically propagated.
      result = $(result)/<mpfr-version>unspecified ;
      # `<mpfr-version-hidden>unspecified' is automatically propagated.
      result = $(result)/<mpc-version>unspecified ;
      # `<mpc-version-hidden>unspecified' is automatically propagated.
      result = $(result)/<gcc-version>unspecified ;
      # `<enable-cross-binutils>yes' is automatically propagated.
      result = $(result)/<enable-cross-crt>unspecified ;
    }
  }
  else {
    # For stage 3.
    if $(enable-cross-binutils) = yes {
      result = <source>../../stage3/binutils//install ;
      # `<intro-stage>3' is automatically propagated.
      # `<intro-host>' is automatically propagated.
      # `<intro-link>unspecified' is automatically propagated.
      # `<intro-multilib>' is automatically propagated.
      # `<intro-multilib-hidden>unspecified' is automatically propagated.
      # `<binutils-version>' is automatically propagated.
      # `<binutils-version-hidden>unspecified' is automatically propagated.
      local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
      result = $(result)/<gmp-version>unspecified ;
      result = $(result)/<gmp-version-hidden>$(gmp-version) ;
      local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
      result = $(result)/<mpfr-version>unspecified ;
      result = $(result)/<mpfr-version-hidden>$(mpfr-version) ;
      local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
      result = $(result)/<mpc-version>unspecified ;
      result = $(result)/<mpc-version-hidden>$(mpc-version) ;
      # `<gcc-version>' is automatically propagated.
      # `<enable-cross-binutils>yes' is automatically propagated.
      # `<enable-cross-crt>' is automatically propagated.
    }
  }
  return $(result) ;
}
alias binutils-dep : : <conditional>@binutils-dep-req ;
explicit binutils-dep ;


rule mpc-dep-req ( properties * )
{
  local result = ../../stage1/gmp//expand/<mpfr-version>unspecified/<mpc-version>unspecified
                 ../../stage1/mpfr//expand/<gmp-version>unspecified/<mpc-version>unspecified
                 ../../stage1/mpc//expand/<gmp-version>unspecified/<mpfr-version>unspecified ;
  result = <source>$(result) ;
  result = $(result)/<intro-stage>1 ;
  result = $(result)/<intro-host>unspecified ;
  # `<intro-link>unspecified' is automatically propagated.
  result = $(result)/<intro-multilib>unspecified ;
  # `<intro-multilib-hidden>unspecified' is automatically propagated.
  result = $(result)/<binutils-version>unspecified ;
  # `<binutils-version-hidden>unspecified' is automatically propagated.
  # `<gmp-version-hidden>unspecified' is automatically propagated.
  # `<mpfr-version-hidden>unspecified' is automatically propagated.
  # `<mpc-version-hidden>unspecified' is automatically propagated.
  result = $(result)/<gcc-version>unspecified ;
  result = $(result)/<enable-cross-binutils>unspecified ;
  result = $(result)/<enable-cross-crt>unspecified ;
  return $(result) ;
}
alias mpc-dep : : <conditional>@mpc-dep-req ;
explicit mpc-dep ;


rule mingw-w64-headers-dep-req ( properties * )
{
  local result ;
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local build = [ SHELL "\"$(INTRO_ROOT_DIR)/stage1/gcc/config.guess\" | tr --delete '\n'" ] ;
  local enable-cross-crt = [ feature.get-values <enable-cross-crt> : $(properties) ] ;
  if $(stage) = 2 {
    if $(enable-cross-crt) = yes {
      if [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
        result = <source>../mingw-w64-headers//install ;
        # `<intro-stage>2' is automatically propagated.
        # `<intro-host>' is automatically propagated.
        # `<intro-link>unspecified' is automatically propagated.
        result = $(result)/<intro-multilib>unspecified ;
        # `<intro-multilib-hidden>unspecified' is automatically propagated.
        result = $(result)/<binutils-version>unspecified ;
        # `<binutils-version-hidden>unspecified' is automatically propagated.
        result = $(result)/<gmp-version>unspecified ;
        # `<gmp-version-hidden>unspecified' is automatically propagated.
        result = $(result)/<mpfr-version>unspecified ;
        # `<mpfr-version-hidden>unspecified' is automatically propagated.
        result = $(result)/<mpc-version>unspecified ;
        # `<mpc-version-hidden>unspecified' is automatically propagated.
        result = $(result)/<gcc-version>unspecified ;
        result = $(result)/<enable-cross-binutils>unspecified ;
        # `<enable-cross-crt>yes' is automatically propagated.
      }
      else if $(build) = x86_64-unknown-linux-gnu && $(HOST) = i686-pc-linux-gnu {
        # Do nothing.
      }
      else {
        errors.error "ERROR: unknown cross target." ;
      }
    }
  }
  return $(result) ;
}
alias mingw-w64-headers-dep : : <conditional>@mingw-w64-headers-dep-req ;
explicit mingw-w64-headers-dep ;


rule gcc-dep-req ( properties * )
{
  local result ;
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  if $(stage) = 3 {
    result = <source>../../stage2/gcc//install ;
    result = $(result)/<intro-stage>2 ;
    # `<intro-host>' is automatically propagated.
    # `<intro-link>unspecified' is automatically propagated.
    # `<intro-multilib>' is automatically propagated.
    # `<intro-multilib-hidden>unspecified' is automatically propagated.
    # `<binutils-version>' is automatically propagated.
    # `<binutils-version-hidden>unspecified' is automatically propagated.
    # `<gmp-version>' is automatically propagated.
    # `<gmp-version-hidden>unspecified' is automatically propagated.
    # `<mpfr-version>' is automatically propagated.
    # `<mpfr-version-hidden>unspecified' is automatically propagated.
    # `<mpc-version>' is automatically propagated.
    # `<mpc-version-hidden>unspecified' is automatically propagated.
    # `<gcc-version>' is automatically propagated.
    # `<enable-cross-crt>' is automatically propagated.
    # `<enable-cross-binutils>' is automatically propagated.
  }
  return $(result) ;
}
alias gcc-dep : : <conditional>@gcc-dep-req ;
explicit gcc-dep ;


rule mingw-w64-crt-dep-req ( properties * )
{
  local result ;
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local enable-cross-crt = [ feature.get-values <enable-cross-crt> : $(properties) ] ;
  if $(stage) = 3 && $(enable-cross-crt) = yes {
    if [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
      result = <source>../../stage3/mingw-w64-crt//install ;
      # `<intro-stage>3' is automatically propagated.
      # `<intro-host>' is automatically propagated.
      # `<intro-link>unspecified' is automatically propagated.
      # `<intro-multilib>' is automatically propagated.
      # `<intro-multilib-hidden>unspecified' is automatically propagated.
      # `<binutils-version>' is automatically propagated.
      # `<binutils-version-hidden>unspecified' is automatically propagated.
      local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
      result = $(result)/<gmp-version>unspecified ;
      result = $(result)/<gmp-version-hidden>$(gmp-version) ;
      local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
      result = $(result)/<mpfr-version>unspecified ;
      result = $(result)/<mpfr-version-hidden>$(mpfr-version) ;
      local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
      result = $(result)/<mpc-version>unspecified ;
      result = $(result)/<mpc-version-hidden>$(mpc-version) ;
      # `<gcc-version>' is automatically propagated.
      # `<enable-cross-binutils>' is automatically propagated.
      # `<enable-cross-crt>yes' is automatically propagated.
    }
    else {
      errors.error "ERROR: unknown cross target." ;
    }
  }
  return $(result) ;
}
alias mingw-w64-crt-dep : : <conditional>@mingw-w64-crt-dep-req ;
explicit mingw-w64-crt-dep ;


make download : : @download-gcc ;
explicit download ;

rule download-gcc ( targets * : sources * : properties * )
{
  local version = [ feature.get-values <gcc-version> : $(properties) ] ;
  URL on $(targets) = http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-$(version)/gcc-$(version).tar.bz2 ;
  TARBALL_GZ on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.gz ;
  TARBALL_BZ2 on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.bz2 ;
}
actions download-gcc
{
  rm -f "$(<)" || exit $?
  if [ ! -f "$(TARBALL_GZ)" -a ! -f "$(TARBALL_BZ2)" ]; then
    ( cd "$(TARBALL_BZ2:D)" && wget --quiet -- '$(URL)' ) \
      || { echo "ERROR: failed to download the GCC tarball." 2>>"$(STDOUT_)" 1>&2; exit 1; }
    [ -f "$(TARBALL_BZ2)" ] || exit 1
  fi
  [ ! -e "$(<)" ] || exit 1
  touch "$(<)"
}


make expand : download : @expand-gcc ;
explicit expand ;

rule expand-gcc ( targets * : sources * : properties * )
{
  if ! $(sources[1]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  if $(sources[2]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  local version = [ feature.get-values <gcc-version> : $(properties) ] ;
  TARBALL_GZ on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.gz ;
  TARBALL_BZ2 on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.bz2 ;
  DEST_DIR on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version) ;
}
actions expand-gcc
{
  rm -f "$(<)" || exit $?
  [ -f "$(>[1])" ] || exit 1
  if [ ! -x "$(DEST_DIR)/configure" ]; then
    rm -rf "$(DEST_DIR)" || exit $?
    if [ -f "$(TARBALL_GZ)" ]; then
      tar xzf "$(TARBALL_GZ)" -C "$(TARBALL_GZ:D)" \
        || { echo "ERROR: failed to expand the tarball for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
    elif [ -f "$(TARBALL_BZ2)" ]; then
      tar xjf "$(TARBALL_BZ2)" -C "$(TARBALL_BZ2:D)" \
        || { echo "ERROR: failed to expand the tarball for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
    else
      exit 1
    fi
    [ -x "$(DEST_DIR)/configure" ] || exit 1
  fi
  [ ! -e "$(<)" ] || exit 1
  touch "$(<)"
}


make configure
  : binutils-dep
    mpc-dep
    mingw-w64-headers-dep
    gcc-dep
    mingw-w64-crt-dep
    ../../stage1/gcc//expand/<intro-host>unspecified/<intro-multilib>unspecified/<binutils-version>unspecified/<gmp-version>unspecified/<mpfr-version>unspecified/<mpc-version>unspecified
  : @configure-gcc
  ;
explicit configure ;

rule configure-gcc ( targets * : sources * : properties * )
{
  OPTIONS on $(targets) = ;

  local version = [ feature.get-values <gcc-version> : $(properties) ] ;

  # Set the path to the 'configure' file.
  local configure = $(INTRO_ROOT_DIR)/gcc-$(version)/configure ;
  CONFIGURE on $(targets) = $(configure) ;

  # Set the '--build', '--host' and '--target' options for the 'configure' script.
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local build = [ SHELL "\"$(INTRO_ROOT_DIR)/stage1/gcc/config.guess\" | tr --delete '\n'" ] ;
  if $(stage) = 1 {
    OPTIONS on $(targets) += --build=$(build) ;
    OPTIONS on $(targets) += --host=$(build) ;
    OPTIONS on $(targets) += --target=$(build) ;
  }
  else if $(stage) = 2 {
    OPTIONS on $(targets) += --build=$(build) ;
    OPTIONS on $(targets) += --host=$(build) ;
    OPTIONS on $(targets) += --target=$(HOST) ;
  }
  else {
    OPTIONS on $(targets) += --build=$(build) ;
    OPTIONS on $(targets) += --host=$(HOST) ;
    OPTIONS on $(targets) += --target=$(HOST) ;
  }

  # Set the '--prefix' option for the 'configure' script.
  if $(stage) = 1 || $(stage) = 2 {
    OPTIONS on $(targets) += --prefix=\"$(PREFIX)\" ;
  }
  else {
    OPTIONS on $(targets) += --prefix=\"$(CROSS_PREFIX)\" ;
  }

  # if $(stage) = 2 {
  #   OPTIONS on $(targets) += --program-prefix=$(HOST)- ;
  # }

  if $(stage) = 1 {
    OPTIONS on $(targets) += --program-suffix=-$(version) ;
  }

  OPTIONS on $(targets) += --enable-shared ;

  local multilib = [ feature.get-values <intro-multilib> : $(properties) ] ;
  if $(multilib) = yes {
    OPTIONS on $(targets) += --enable-multilib ;
  }
  else {
    OPTIONS on $(targets) += --disable-multilib ;
  }

  OPTIONS on $(targets) += --enable-libstdcxx-debug ;

  OPTIONS on $(targets) += --disable-libstdcxx-pch ;

  OPTIONS on $(targets) += --enable-threads ;

  # if $(stage) = 1 || ( $(stage) = 3 && $(HOST_RUNNABLE) = yes ) {
  #   OPTIONS on $(targets) += --enable-bootstrap ;
  # }
  # else {
  #   OPTIONS on $(targets) += --disable-bootstrap ;
  # }

  OPTIONS on $(targets) += --enable-version-specific-runtime-libs ;

  OPTIONS on $(targets) += --enable-languages=c,c++ ;

  if $(stage) = 1 && [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
    # The target is `*-w64-mingw32.'
    # `--enable-libgomp' option requires `pthreads-w32' on the target.
    # Currently, just disable this option.
    OPTIONS on $(targets) += --disable-libgomp ;
  }
  else if ( $(stage) = 2 || $(stage) = 3 ) && [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
    # The target is `*-w64-mingw32.'
    # `--enable-libgomp' option requires `pthreads-w32' on the target.
    # Currently, just disable this option.
    OPTIONS on $(targets) += --disable-libgomp ;
  }
  else {
    OPTIONS on $(targets) += --enable-libgomp ;
  }

  # `--with-dwarf2' is not supported on 64-bit MinGW-w64 targets,
  # so currently disable this option for any `*-w64-mingw32' targets.
  # Note that this option also disabled for 32-bit MinGW-w64 targets,
  # on which it is supported. Support of this option for 32-bit
  # MinGW-w64 is in my to-do list.
  # if [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
  #   OPTIONS on $(targets) += --with-dwarf2 ;
  # }

  if $(multilib) = yes {
    if $(stage) = 1 {
      if [ regex.match "^(x86_64-)" : $(build) : 1 ] {
        OPTIONS on $(targets) += --enable-targets=all ;
      }
    }
    else {
      if [ regex.match "^(x86_64-)" : $(HOST) : 1 ] {
        OPTIONS on $(targets) += --enable-targets=all ;
      }
    }
  }

  # Set `--disable-win32-registry' and `--disable-nls' options for Windows hosts.
  if ( $(stage) = 1 || $(stage) = 2 ) && [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
    OPTIONS on $(targets) += --disable-win32-registry ;
    OPTIONS on $(targets) += --disable-nls ;
  }
  else if $(stage) = 3 && [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
    OPTIONS on $(targets) += --disable-win32-registry ;
    OPTIONS on $(targets) += --disable-nls ;
  }

  # # Set the `--with-gmp', `--with-mpfr' and `--with-mpc' options for the 'configure' script.
  # if $(stage) = 1 || $(stage) = 2 {
  #   OPTIONS on $(targets) += --with-gmp=\"$(PREFIX)\" ;
  #   OPTIONS on $(targets) += --with-mpfr=\"$(PREFIX)\" ;
  #   OPTIONS on $(targets) += --with-mpc=\"$(PREFIX)\" ;
  # }

  # Set the '--with-sysroot' option for the 'configure' script.
  if $(stage) = 2 {
    OPTIONS on $(targets) += --with-sysroot=\"$(PREFIX)\" ;
  }
  else if $(stage) = 3 {
    OPTIONS on $(targets) += --with-sysroot=\"$(CROSS_PREFIX)\" ;
  }

  # See the note for `--with-dwarf2' option.
  # if [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
  #   OPTIONS on $(targets) += --disable-sjlj-exceptions ;
  # }

  SET_RUNTIME_SYMLINK on $(targets) = ;
  UNSET_RUNTIME_SYMLINK on $(targets) = ;
  if $(stage) = 2 {
    SET_RUNTIME_SYMLINK on $(targets) = $(STAGE2_SET_RUNTIME_SYMLINK) ;
    UNSET_RUNTIME_SYMLINK on $(targets) = $(STAGE2_UNSET_RUNTIME_SYMLINK) ;
  }
  else if $(stage) = 3 {
    SET_RUNTIME_SYMLINK on $(targets) = "$(STAGE2_SET_RUNTIME_SYMLINK); $(STAGE3_SET_RUNTIME_SYMLINK)" ;
    UNSET_RUNTIME_SYMLINK on $(targets) = "$(STAGE2_UNSET_RUNTIME_SYMLINK); $(STAGE3_UNSET_RUNTIME_SYMLINK)" ;
  }

  local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
  SET_GMP_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/gmp-$(gmp-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/gmp\"" ;
  UNSET_GMP_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/gmp\"" ;

  local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
  SET_MPFR_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/mpfr-$(mpfr-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpfr\"" ;
  UNSET_MPFR_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpfr\"" ;

  local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
  SET_MPC_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/mpc-$(mpc-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpc\"" ;
  UNSET_MPC_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpc\"" ;

  SET_MINGW_WINSUP_SYMLINK on $(targets) = ;
  UNSET_MINGW_WINSUP_SYMLINK on $(targets) = ;
  if $(stage) = 3 && [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
    SET_MINGW_WINSUP_SYMLINK on $(targets) = "{ mkdir -p \"$(INTRO_ROOT_DIR)/gcc-$(version)/winsup/mingw\" && ( cd \"$(INTRO_ROOT_DIR)/gcc-$(version)/winsup/mingw\" && mkdir -p \"$(CROSS_PREFIX)/$(HOST)/include\" && ln -sf \"$(CROSS_PREFIX)/$(HOST)/include\" include ); } || exit $?" ;
    UNSET_MINGW_WINSUP_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/winsup/mingw/include\"" ;
  }

  SET_RUN_VARS on $(targets) = ;
  UNSET_RUN_VARS on $(targets) = ;
  if $(stage) = 1 {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
    }
    else {
      SET_RUN_VARS on $(targets) = "OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export LD_LIBRARY_PATH" ;
      UNSET_RUN_VARS on $(targets) = "LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export LD_LIBRARY_PATH" ;
    }
  }
  else if $(stage) = 2 {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
    }
    else {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
    }
  }
  else {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      if $(HOST_RUNNABLE) = yes {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":\"$(CROSS_PREFIX)/bin\":$PATH; export PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
      }
      else {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
      }
    }
    else {
      if $(HOST_RUNNABLE) = yes {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":\"$(CROSS_PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      }
      else {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      }
    }
  }
}
actions configure-gcc
{
  rm -f "$(<)" || exit $?
  [ -x "$(CONFIGURE)" ] || exit 1
  { mkdir -p "$(<:D)/build" && ( cd "$(<:D)/build" && rm -rf * ); } || exit $?
  $(SET_RUNTIME_SYMLINK)
  $(SET_GMP_SYMLINK)
  $(SET_MPFR_SYMLINK)
  $(SET_MPC_SYMLINK)
  $(SET_MINGW_WINSUP_SYMLINK)
  $(SET_RUN_VARS)
  ( cd "$(<:D)/build" && "$(CONFIGURE)" $(OPTIONS) 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    $(UNSET_MINGW_WINSUP_SYMLINK)
    $(UNSET_MPC_SYMLINK)
    $(UNSET_MPFR_SYMLINK)
    $(UNSET_GMP_SYMLINK)
    $(UNSET_RUNTIME_SYMLINK)
    echo "ERROR: failed to 'configure' for the GCC build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  $(UNSET_RUN_VARS)
  $(UNSET_MINGW_WINSUP_SYMLINK)
  $(UNSET_MPC_SYMLINK)
  $(UNSET_MPFR_SYMLINK)
  $(UNSET_GMP_SYMLINK)
  $(UNSET_RUNTIME_SYMLINK)
  [ -f "$(<:D)/build/Makefile" ] || exit 1
  [ ! -e "$(<)" ] || exit 1
  touch "$(<)"
}


make mingw32-stage1.make : configure : @make-mingw32-stage1 ;
explicit mingw32-stage1.make ;

rule make-mingw32-stage1 ( targets * : sources * : properties * )
{
  if ! $(sources[1]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  if $(sources[2]) {
    errors.error "ERROR: wrong number of sources." ;
  }

  local version = [ feature.get-values <gcc-version> : $(properties) ] ;
  SRC_DIR on $(targets) = "$(INTRO_ROOT_DIR)/gcc-$(version)" ;

  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  if $(stage) != 2 {
    errors.error "ERROR: internal error." ;
  }

  local build = [ SHELL "\"$(INTRO_ROOT_DIR)/stage1/gcc/config.guess\" | tr --delete '\n'" ] ;

  local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
  SET_GMP_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/gmp-$(gmp-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/gmp\"" ;
  UNSET_GMP_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/gmp\"" ;

  local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
  SET_MPFR_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/mpfr-$(mpfr-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpfr\"" ;
  UNSET_MPFR_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpfr\"" ;

  local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
  SET_MPC_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/mpc-$(mpc-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpc\"" ;
  UNSET_MPC_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpc\"" ;

  SET_RUN_VARS on $(targets) = ;
  UNSET_RUN_VARS on $(targets) = ;
  if $(stage) = 1 {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
    }
    else {
      SET_RUN_VARS on $(targets) = "OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export LD_LIBRARY_PATH" ;
      UNSET_RUN_VARS on $(targets) = "LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export LD_LIBRARY_PATH" ;
    }
  }
  else if $(stage) = 2 {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
    }
    else {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
    }
  }
  else {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      if $(HOST_RUNNABLE) = yes {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":\"$(CROSS_PREFIX)/bin\":$PATH; export PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
      }
      else {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
      }
    }
    else {
      if $(HOST_RUNNABLE) = yes {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":\"$(CROSS_PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      }
      else {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      }
    }
  }
}
actions make-mingw32-stage1
{
  rm -f "$(<)" || exit 1
  [ -f "$(>[1])" ] || exit 1
  [ -f "$(>[1]:D)/build/Makefile" ] || exit 1
  $(SET_GMP_SYMLINK)
  $(SET_MPFR_SYMLINK)
  $(SET_MPC_SYMLINK)
  ln -sf "$(PREFIX)/$(HOST)" "$(PREFIX)/mingw" || exit 1
  $(SET_RUN_VARS)
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) all-gcc 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    rm "$(PREFIX)/mingw"
    $(UNSET_MPC_SYMLINK)
    $(UNSET_MPFR_SYMLINK)
    $(UNSET_GMP_SYMLINK)
    echo "ERROR: failed to 'make all-gcc' for the GCC build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) install-gcc 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    rm "$(PREFIX)/mingw"
    $(UNSET_MPC_SYMLINK)
    $(UNSET_MPFR_SYMLINK)
    $(UNSET_GMP_SYMLINK)
    echo "ERROR: failed to 'make install-gcc' for the GCC build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  $(UNSET_RUN_VARS)
  rm "$(PREFIX)/mingw"
  $(UNSET_MPC_SYMLINK)
  $(UNSET_MPFR_SYMLINK)
  $(UNSET_GMP_SYMLINK)
  [ ! -e "$(<)" ] || exit 1
  touch "$(<)"
}


rule make-req ( properties * )
{
  local result ;
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local enable-cross-crt = [ feature.get-values <enable-cross-crt> : $(properties) ] ;
  if $(stage) = 2 && $(enable-cross-crt) = yes {
    if [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
      result = <source>../../stage2/mingw-w64-crt//install ;
      # `<intro-stage>2' is automatically propagated.
      # `<intro-host>' is automatically propagated.
      # `<intro-link>unspecified' is automatically propagated.
      # `<intro-multilib>' is automatically propagated.
      # `<intro-multilib-hidden>unspecified' is automatically propagated.
      # `<binutils-version>' is automatically propagated.
      # `<binutils-version-hidden>unspecified' is automatically propagated.
      local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
      result = $(result)/<gmp-version>unspecified ;
      result = $(result)/<gmp-version-hidden>$(gmp-version) ;
      local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
      result = $(result)/<mpfr-version>unspecified ;
      result = $(result)/<mpfr-version-hidden>$(mpfr-version) ;
      local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
      result = $(result)/<mpc-version>unspecified ;
      result = $(result)/<mpc-version-hidden>$(mpc-version) ;
      # `<gcc-version>' is automatically propagated.
      # `<enable-cross-binutils>' is automatically propagated.
      # `<enable-cross-crt>yes' is automatically propagated.
    }
    else {
      errors.error "ERROR: unknown cross target." ;
    }
  }
  else {
    result = <source>configure ;
  }
  return $(result) ;
}

make make : : @make-gcc : <conditional>@make-req ;
explicit make ;

rule make-gcc ( targets * : sources * : properties * )
{
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local build = [ SHELL "\"$(INTRO_ROOT_DIR)/stage1/gcc/config.guess\" | tr --delete '\n'" ] ;
  local version = [ feature.get-values <gcc-version> : $(properties) ] ;

  STAGE on $(targets) = $(stage) ;

  VERSION on $(targets) = $(version) ;

  SET_RUNTIME_SYMLINK on $(targets) = ;
  UNSET_RUNTIME_SYMLINK on $(targets) = ;
  if $(stage) = 2 {
    SET_RUNTIME_SYMLINK on $(targets) = $(STAGE2_SET_RUNTIME_SYMLINK) ;
    UNSET_RUNTIME_SYMLINK on $(targets) = $(STAGE2_UNSET_RUNTIME_SYMLINK) ;
  }
  else if $(stage) = 3 {
    SET_RUNTIME_SYMLINK on $(targets) = "$(STAGE2_SET_RUNTIME_SYMLINK); $(STAGE3_SET_RUNTIME_SYMLINK)" ;
    UNSET_RUNTIME_SYMLINK on $(targets) = "$(STAGE2_UNSET_RUNTIME_SYMLINK); $(STAGE3_UNSET_RUNTIME_SYMLINK)" ;
  }

  local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
  SET_GMP_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/gmp-$(gmp-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/gmp\"" ;
  UNSET_GMP_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/gmp\"" ;

  local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
  SET_MPFR_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/mpfr-$(mpfr-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpfr\"" ;
  UNSET_MPFR_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpfr\"" ;

  local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
  SET_MPC_SYMLINK on $(targets) = "ln -sf \"$(INTRO_ROOT_DIR)/mpc-$(mpc-version)\" \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpc\"" ;
  UNSET_MPC_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/mpc\"" ;

  SET_MINGW_WINSUP_SYMLINK on $(targets) = ;
  UNSET_MINGW_WINSUP_SYMLINK on $(targets) = ;
  if $(stage) = 3 && [ regex.match "(-w64-mingw32)$" : $(HOST) : 1 ] {
    SET_MINGW_WINSUP_SYMLINK on $(targets) = "{ mkdir -p \"$(INTRO_ROOT_DIR)/gcc-$(version)/winsup/mingw\" && ( cd \"$(INTRO_ROOT_DIR)/gcc-$(version)/winsup/mingw\" && mkdir -p \"$(CROSS_PREFIX)/$(HOST)/include\" && ln -sf \"$(CROSS_PREFIX)/$(HOST)/include\" include ); } || exit $?" ;
    UNSET_MINGW_WINSUP_SYMLINK on $(targets) = "rm \"$(INTRO_ROOT_DIR)/gcc-$(version)/winsup/mingw/include\"" ;
  }

  SET_RUN_VARS on $(targets) = ;
  UNSET_RUN_VARS on $(targets) = ;
  if $(stage) = 1 {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
    }
    else {
      SET_RUN_VARS on $(targets) = "OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export LD_LIBRARY_PATH" ;
      UNSET_RUN_VARS on $(targets) = "LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export LD_LIBRARY_PATH" ;
    }
  }
  else if $(stage) = 2 {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
    }
    else {
      SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
    }
  }
  else {
    if [ regex.match "(-w64-mingw32)$" : $(build) : 1 ] {
      if $(HOST_RUNNABLE) = yes {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":\"$(CROSS_PREFIX)/bin\":$PATH; export PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
      }
      else {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; PATH=\"$(PREFIX)/bin\":$PATH; export PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; export PATH" ;
      }
    }
    else {
      if $(HOST_RUNNABLE) = yes {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":\"$(CROSS_PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      }
      else {
        SET_RUN_VARS on $(targets) = "OLD_PATH=$PATH; OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH; PATH=\"$(PREFIX)/bin\":$PATH; LD_LIBRARY_PATH=\"$(PREFIX)/lib\":$LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
        UNSET_RUN_VARS on $(targets) = "PATH=$OLD_PATH; LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH; export PATH; export LD_LIBRARY_PATH" ;
      }
    }
  }
}
actions make-gcc
{
  rm -f "$(<)" || exit 1
  [ -f "$(<:D)/build/Makefile" ] || exit 1
  $(SET_RUNTIME_SYMLINK)
  $(SET_GMP_SYMLINK)
  $(SET_MPFR_SYMLINK)
  $(SET_MPC_SYMLINK)
  $(SET_MINGW_WINSUP_SYMLINK)
  $(SET_RUN_VARS)
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    $(UNSET_MINGW_WINSUP_SYMLINK)
    $(UNSET_MPC_SYMLINK)
    $(UNSET_MPFR_SYMLINK)
    $(UNSET_GMP_SYMLINK)
    $(UNSET_RUNTIME_SYMLINK)
    echo "ERROR: failed to 'make' for the GCC build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) install 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    $(UNSET_MINGW_WINSUP_SYMLINK)
    $(UNSET_MPC_SYMLINK)
    $(UNSET_MPFR_SYMLINK)
    $(UNSET_GMP_SYMLINK)
    $(UNSET_RUNTIME_SYMLINK)
    echo "ERROR: failed to 'make install' for the GCC build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  $(UNSET_RUN_VARS)
  $(UNSET_MINGW_WINSUP_SYMLINK)
  $(UNSET_MPC_SYMLINK)
  $(UNSET_MPFR_SYMLINK)
  $(UNSET_GMP_SYMLINK)
  $(UNSET_RUNTIME_SYMLINK)
  if [ $(STAGE) -eq 2 ]; then
    find "$(PREFIX)/bin" -maxdepth 1 -type f | grep -Eq ".+\\.dll$" && mv -n "$(PREFIX)/bin"/*.dll "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    find "$(PREFIX)/bin" -maxdepth 1 -type f | grep -Eq ".+\\.dll$" && exit 1
    [ -f "$(PREFIX)/lib/gcc/$(HOST)/lib/libgcc_s.a" ] && mv -n "$(PREFIX)/lib/gcc/$(HOST)/lib/libgcc_s.a" "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    [ -f "$(PREFIX)/lib/gcc/$(HOST)/lib/libgcc_s.a" ] && exit 1
    [ -f "$(PREFIX)/lib/gcc/$(HOST)/lib64/libgcc_s.a" ] && mv -n "$(PREFIX)/lib/gcc/$(HOST)/lib64/libgcc_s.a" "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    [ -f "$(PREFIX)/lib/gcc/$(HOST)/lib64/libgcc_s.a" ] && exit 1
    [ -f "$(PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" -a -d "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/" ] && mv -n "$(PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/"
    [ -f "$(PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" -a ! -d "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/" ] && mv -n "$(PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    [ -f "$(PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" ] && exit 1
    find "$(PREFIX)/lib/gcc/$(HOST)" -maxdepth 1 -type f | grep -Eq "^libgcc_s_.+\\.dll$" && mv -n "$(PREFIX)/lib/gcc/$(HOST)"/libgcc_s_*.dll "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    find "$(PREFIX)/lib/gcc/$(HOST)" -maxdepth 1 -type f | grep -Eq ".+" && exit 1
    find "$(PREFIX)/lib/gcc/$(HOST)/32" -maxdepth 1 -type f | grep -Eq "^libgcc_s_.+\\.dll$" && mv -n "$(PREFIX)/lib/gcc/$(HOST)/32"/libgcc_s_*.dll "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/"
    find "$(PREFIX)/lib/gcc/$(HOST)/32" -maxdepth 1 -type f | grep -Eq ".+" && exit 1
    [ -d "$(PREFIX)/lib/gcc/$(HOST)/lib" ] && { rmdir "$(PREFIX)/lib/gcc/$(HOST)/lib" || exit 1; }
    [ -d "$(PREFIX)/lib/gcc/$(HOST)/lib64" ] && { rmdir "$(PREFIX)/lib/gcc/$(HOST)/lib64" || exit 1; }
    [ -d "$(PREFIX)/lib/gcc/$(HOST)/lib32" ] && { rmdir "$(PREFIX)/lib/gcc/$(HOST)/lib32" || exit 1; }
    [ -d "$(PREFIX)/lib/gcc/$(HOST)/32" ] && { rmdir "$(PREFIX)/lib/gcc/$(HOST)/32" || exit 1; }
  elif [ $(STAGE) -eq 3 ]; then
    find "$(CROSS_PREFIX)/bin" -maxdepth 1 -type f | grep -Eq ".+\\.dll$" && mv -n "$(CROSS_PREFIX)/bin"/*.dll "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    find "$(CROSS_PREFIX)/bin" -maxdepth 1 -type f | grep -Eq ".+\\.dll$" && exit 1
    [ -f "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib/libgcc_s.a" ] && mv -n "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib/libgcc_s.a" "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    [ -f "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib/libgcc_s.a" ] && exit 1
    [ -f "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib64/libgcc_s.a" ] && mv -n "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib64/libgcc_s.a" "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    [ -f "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib64/libgcc_s.a" ] && exit 1
    [ -f "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" -a -d "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/" ] && mv -n "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/"
    [ -f "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" -a ! -d "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/" ] && mv -n "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    [ -f "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib32/libgcc_s.a" ] && exit 1
    find "$(CROSS_PREFIX)/lib/gcc/$(HOST)" -maxdepth 1 -type f | grep -Eq "^libgcc_s_.+\\.dll$" && mv -n "$(CROSS_PREFIX)/lib/gcc/$(HOST)"/libgcc_s_*.dll "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    find "$(CROSS_PREFIX)/lib/gcc/$(HOST)" -maxdepth 1 -type f | grep -Eq ".+" && exit 1
    find "$(CROSS_PREFIX)/lib/gcc/$(HOST)/32" -maxdepth 1 -type f | grep -Eq "^libgcc_s_.+\\.dll$" && mv -n "$(CROSS_PREFIX)/lib/gcc/$(HOST)/32"/libgcc_s_*.dll "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/"
    find "$(CROSS_PREFIX)/lib/gcc/$(HOST)/32" -maxdepth 1 -type f | grep -Eq ".+" && exit 1
    cp -n "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)"/*.dll "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/"
    [ -d "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32" ] && cp -n "$(PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32"/*.dll "$(CROSS_PREFIX)/lib/gcc/$(HOST)/$(VERSION)/32/"
    [ -d "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib" ] && { rmdir "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib" || exit 1; }
    [ -d "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib64" ] && { rmdir "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib64" || exit 1; }
    [ -d "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib32" ] && { rmdir "$(CROSS_PREFIX)/lib/gcc/$(HOST)/lib32" || exit 1; }
    [ -d "$(CROSS_PREFIX)/lib/gcc/$(HOST)/32" ] && { rmdir "$(CROSS_PREFIX)/lib/gcc/$(HOST)/32" || exit 1; }
  fi
  [ ! -e "$(<)" ] || exit 1
  touch "$(<)"
}


rule install-req ( properties * )
{
  local result = <source>make ;

  local tmp ;

  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;

  local build = [ SHELL "\"$(INTRO_ROOT_DIR)/stage1/gcc/config.guess\" | tr --delete '\n'" ] ;

  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  if $(stage) = 1 && $(host) != unspecified {
    errors.error "ERROR: `<intro-host>$(host)' is not valid for the GCC stage 1 build." ;
  }
  if ( $(stage) = 2 || $(stage) = 3 ) && $(host) = unspecified {
    errors.error "ERROR: `<intro-host>' is not specified for the GCC stage 2 or 3 build." ;
  }
  if $(host) != unspecified {
    tmp = [ SHELL "\"$(INTRO_ROOT_DIR)/stage1/gcc/config.sub\" $(host) | tr --delete '\n'" ] ;
    if $(tmp) != $(host) {
      errors.error "ERROR: `<intro-host>$(host)' is not canonical for the GCC build." ;
    }
  }

  local link = [ feature.get-values <intro-link> : $(properties) ] ;
  if $(link) != unspecified {
    errors.error "ERROR: `<intro-link>$(link)' is not valid for the GCC build." ;
  }

  local multilib = [ feature.get-values <intro-multilib> : $(properties) ] ;
  if $(multilib) = unspecified {
    errors.error "ERROR: `<intro-multilib>' is not specified for the GCC build." ;
  }
  if $(multilib) = yes {
    if $(stage) = 1 {
      if [ regex.match "^(x86_64-)" : $(build) : 1 ] {
        # Do nothing.
      }
      else {
        errors.error "ERROR: `multilib' is not supported on `$(build)'." ;
      }
    }
    else {
      # For stage 2 or 3.
      if [ regex.match "^(x86_64-)" : $(HOST) : 1 ] {
        # Do nothing.
      }
      else {
        errors.error "ERROR: `multilib' is not supported on `$(HOST)'." ;
      }
    }
  }
  multilib = [ feature.get-values <intro-multilib-hidden> : $(properties) ] ;
  if $(multilib) != unspecified {
    errors.error "ERROR: `<intro-multilib-hidden>$(multilib)' is not valid for the GCC build." ;
  }

  local binutils-version = [ feature.get-values <binutils-version> : $(properties) ] ;
  if $(stage) = 1 && $(binutils-version) != unspecified {
    errors.error "ERROR: `<binutils-version>$(binutils-version)' is not valid for the GCC stage 1 build." ;
  }
  if ( $(stage) = 2 || $(stage) = 3 ) && $(binutils-version) = unspecified {
    errors.error "ERROR: `<binutils-version>' is not specified for the GCC stage 2 or 3 build." ;
  }
  binutils-version = [ feature.get-values <binutils-version-hidden> : $(properties) ] ;
  if $(binutils-version) != unspecified {
    errors.error "ERROR: `<binutils-version-hidden>$(binutils-version)' is not valid for the GCC build." ;
  }

  local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
  if $(gmp-version) = unspecified {
    errors.error "ERROR: `<gcc-version>' is not specified for the GCC build." ;
  }
  gmp-version = [ feature.get-values <gmp-version-hidden> : $(properties) ] ;
  if $(gmp-version) != unspecified {
    errors.error "ERROR: `<gmp-version-hidden>$(gmp-version)' is not valid for the GCC build." ;
  }

  local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
  if $(mpfr-version) = unspecified {
    errors.error "ERROR: `<mpfr-version>' is not specified for the GCC build." ;
  }
  mpfr-version = [ feature.get-values <mpfr-version-hidden> : $(properties) ] ;
  if $(mpfr-version) != unspecified {
    errors.error "ERROR: `<mpfr-version-hidden>$(mpfr-version)' is not valid for the GCC build." ;
  }

  local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
  if $(mpc-version) = unspecified {
    errors.error "ERROR: `<mpc-version>' is not specified for the GCC build." ;
  }
  mpc-version = [ feature.get-values <mpc-version-hidden> : $(properties) ] ;
  if $(mpc-version) != unspecified {
    errors.error "ERROR: `<mpc-version-hidden>$(mpc-version)' is not valid for the GCC build." ;
  }

  local gcc-version = [ feature.get-values <gcc-version> : $(properties) ] ;
  if $(gcc-version) = unspecified {
    errors.error "ERROR: `<gcc-version>' is not specified for the GCC build." ;
  }

  if [ SHELL "{ ( LC_ALL=C gcc -v 2>&1 ) | grep -Eq '^gcc version $(gcc-version)'; } && /bin/echo -n 'yes'" ] = yes {
    result = <build>no ;
  }

  local enable-cross-binutils = [ feature.get-values <enable-cross-binutils> : $(properties) ] ;
  if $(stage) = 1 {
    if $(enable-cross-binutils) != unspecified {
      errors.error "ERROR: `<enable-cross-binutils>$(enable-cross-binutils)' is not valid for the GCC stage 1 build." ;
    }
  }
  else {
    # For stage 2 or 3.
    if $(enable-cross-binutils) = unspecified {
      errors.error "ERROR: `<enable-cross-binutils>' is not specified for the GCC stage 2 or 3 build." ;
    }
  }

  local enable-cross-crt = [ feature.get-values <enable-cross-crt> : $(properties) ] ;
  if $(stage) = 1 {
    if $(enable-cross-crt) != unspecified {
      errors.error "ERROR: `<enable-cross-crt>$(enable-cross-crt)' is not valid for the GCC stage 1 build." ;
    }
  }
  else {
    # For stage 2 or 3.
    if $(enable-cross-crt) = unspecified {
      errors.error "ERROR: `<enable-cross-crt>' is not specified for the GCC stage 2 or 3 build." ;
    }
  }

  return $(result) ;
}

alias install : : <conditional>@install-req ;
explicit install ;
