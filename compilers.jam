import common ;
import errors ;
import feature ;
import os ;
import path ;
import regex ;

local .root-dir ;

local .gcc-versions ;
local .gcc-current-version ;
local .gcc-previous-version ;
local .gcc-oldest-version ;
local .gcc-snapshot-version ;
local .gcc-current-latest-version ;
local .gcc-previous-snapshot-version ;
local .gcc-oldest-snapshot-version ;

local .clang-versions ;
local .clang-latest-version ;

rule init ( root-dir )
{
  if $(.root-dir)
  {
    errors.error "an internal error." ;
  }

  .root-dir = [ path.make "$(root-dir)" ] ;

  .gcc-versions = [ SHELL "\"$(.root-dir)/gcc-release-versions.sh\" || echo -n error" ] ;
  if $(.gcc-versions) = error
  {
    errors.error "failed to extract GCC release versions." ;
  }
  .gcc-versions = [ regex.split "$(.gcc-versions)" " +" ] ;

  .clang-versions = [ SHELL "\"$(.root-dir)/clang/versions.sh\" || echo -n error" ] ;
  if $(.clang-versions) = error
  {
    errors.error "failed to extract Clang versions." ;
  }
  .clang-versions = [ regex.split "$(.clang-versions)" " +" ] ;
}

rule .init-gcc-release-aliases ( )
{
  if ! $(.gcc-current-version)
  {
    if $(.gcc-previous-version) || $(.gcc-oldest-version)
    {
      errors.error "an internal error." ;
    }

    local gcc-recent-majors
      = [ SHELL "echo -n \"$(.gcc-versions:J= )\" \\
                   | grep -Eo \"[[:digit:]]+\\.[[:digit:]]+\\.[[:digit:]]+\" \\
                   | grep -Eo \"^[[:digit:]]+\\.[[:digit:]]+\" \\
                   | sort -u -t '.' -k 1,1n -k 2,2n \\
                   | tail --lines=3 \\
                   | tr '\\n' ' '" ] ;

    local gcc-current-major
      = [ SHELL "echo -n $(gcc-recent-majors) | tr ' ' '\\n' | tail --lines=1 | tr --delete '\\n'" ] ;
    local gcc-current-version
      = [ SHELL "echo -n $(.gcc-versions:J= ) | grep -Eo \"$(gcc-current-major)\\.[[:digit:]]+\" | sort -u -t '.' -k 1,1n -k 2,2n -k 3,3n | tail --lines=1 | tr --delete '\\n'" ] ;
    .gcc-current-version = $(gcc-current-version) ;

    local gcc-previous-major
      = [ SHELL "echo -n $(gcc-recent-majors) | tr ' ' '\\n' | tail --lines=2 | head --lines=1 | tr --delete '\\n'" ] ;
    local gcc-previous-version
      = [ SHELL "echo -n $(.gcc-versions:J= ) | grep -Eo \"$(gcc-previous-major)\\.[[:digit:]]+\" | sort -u -t '.' -k 1,1n -k 2,2n -k 3,3n | tail --lines=1 | tr --delete '\\n'" ] ;
    .gcc-previous-version = $(gcc-previous-version) ;

    local gcc-oldest-major
      = [ SHELL "echo -n $(gcc-recent-majors) | tr ' ' '\\n' | tail --lines=3 | head --lines=1 | tr --delete '\\n'" ] ;
    local gcc-oldest-version
      = [ SHELL "echo -n $(.gcc-versions:J= ) | grep -Eo \"$(gcc-oldest-major)\\.[[:digit:]]+\" | sort -u -t '.' -k 1,1n -k 2,2n -k 3,3n | tail --lines=1 | tr --delete '\\n'" ] ;
    .gcc-oldest-version = $(gcc-oldest-version) ;
  }
}

rule .init-gcc-snapshot-aliases-impl ( major )
{
  return [ SHELL "echo -n \"$(.gcc-versions:J= )\" | grep -Eo \"$(major)(\\.0-RC)?-[[:digit:]]{8}\" | grep -Eo \"[[:digit:]]{8}\" | sort --numeric-sort | tail --lines=1 | tr --delete '\\n'" ] ;
}

rule .init-gcc-snapshot-aliases ( )
{
  if ! $(.gcc-snapshot-version)
  {
    if $(.gcc-current-snapshot-version) || $(.gcc-previous-snapshot-version) || $(.gcc-oldest-snapshot-version)
    {
      errors.error "an internal error." ;
    }

    local gcc-snapshot-major
      = [ SHELL "{ echo -n \"$(.gcc-versions:J= )\"                                      || echo -n error; } \\
                   | { grep -Eo \"[[:digit:]]+\\.[[:digit:]]+(\\.0-RC)?-[[:digit:]]{8}\" || echo -n error; } \\
                   | { grep -Eo \"^[[:digit:]]+\\.[[:digit:]]+\"                         || echo -n error; } \\
                   | { sort -u -t '.' -k 1,1n -k 2,2n                                    || echo -n error; } \\
                   | { tail --lines=1                                                    || echo -n error; } \\
                   | { tr --delete '\\n'                                                 || echo -n error; }" ] ;
    local gcc-snapshot-date = [ .init-gcc-snapshot-aliases-impl $(gcc-snapshot-major) ] ;
    .gcc-snapshot-version
      = [ SHELL "{ echo -n \"$(.gcc-versions:J= )\"                                      || echo -n error; } \\
                   | { grep -Eo \"$(gcc-snapshot-major)(\\.0-RC)?-$(gcc-snapshot-date)\" || echo -n error; } \\
                   | { tail --lines=1                                                    || echo -n error; } \\
                   | { tr --delete '\\n'                                                 || echo -n error; }" ] ;
    if $(.gcc-snapshot-version) = error
    {
      errors.error "failed to extract GCC snapshot versions." ;
    }

    local gcc-current-snapshot-major = [ regex.match "^([0-9]+\\.[0-9]+)\\.[0-9]+$" : [ get-gcc-current-version ] : 1 ] ;
    local gcc-current-snapshot-date = [ .init-gcc-snapshot-aliases-impl $(gcc-current-snapshot-major) ] ;
    .gcc-current-snapshot-version
      = [ SHELL "{ echo -n \"$(.gcc-versions:J= )\"                                                      || echo -n error; } \\
                   | { grep -Eo \"$(gcc-current-snapshot-major)(\\.0-RC)?-$(gcc-current-snapshot-date)\" || echo -n error; } \\
                   | { tail --lines=1                                                                    || echo -n error; } \\
                   | { tr --delete '\\n'                                                                 || echo -n error; }" ] ;
    if $(.gcc-current-snapshot-version) = error
    {
      errors.error "failed to extract GCC snapshot versions." ;
    }

    local gcc-previous-snapshot-major = [ regex.match "^([0-9]+\\.[0-9]+)\\.[0-9]+$" : [ get-gcc-previous-version ] : 1 ] ;
    local gcc-previous-snapshot-date = [ .init-gcc-snapshot-aliases-impl $(gcc-previous-snapshot-major) ] ;
    .gcc-previous-snapshot-version
      = [ SHELL "{ echo -n \"$(.gcc-versions:J= )\"                                                        || echo -n error; } \\
                   | { grep -Eo \"$(gcc-previous-snapshot-major)(\\.0-RC)?-$(gcc-previous-snapshot-date)\" || echo -n error; } \\
                   | { tail --lines=1                                                                      || echo -n error; } \\
                   | { tr --delete '\\n'                                                                   || echo -n error; }" ] ;
    if $(.gcc-previous-snapshot-version) = error
    {
      errors.error "failed to extract GCC snapshot versions." ;
    }

    local gcc-oldest-snapshot-major = [ regex.match "^([0-9]+\\.[0-9]+)\\.[0-9]+$" : [ get-gcc-oldest-version ] : 1 ] ;
    local gcc-oldest-snapshot-date = [ .init-gcc-snapshot-aliases-impl $(gcc-oldest-snapshot-major) ] ;
    .gcc-oldest-snapshot-version
      = [ SHELL "{ echo -n \"$(.gcc-versions:J= )\"                                                    || echo -n error; } \\
                   | { grep -Eo \"$(gcc-oldest-snapshot-major)(\\.0-RC)?-$(gcc-oldest-snapshot-date)\" || echo -n error; } \\
                   | { tail --lines=1                                                                  || echo -n error; } \\
                   | { tr --delete '\\n'                                                               || echo -n error; }" ] ;
    if $(.gcc-oldest-snapshot-version) = error
    {
      errors.error "failed to extract GCC snapshot versions." ;
    }
  }
}

rule get-gcc-current-version ( )
{
  .init-gcc-release-aliases ;
  return $(.gcc-current-version) ;
}

rule get-gcc-previous-version ( )
{
  .init-gcc-release-aliases ;
  return $(.gcc-previous-version) ;
}

rule get-gcc-oldest-version ( )
{
  .init-gcc-release-aliases ;
  return $(.gcc-oldest-version) ;
}

rule get-gcc-snapshot-version ( )
{
  .init-gcc-snapshot-aliases ;
  return $(.gcc-snapshot-version) ;
}

rule get-gcc-current-snapshot-version ( )
{
  .init-gcc-snapshot-aliases ;
  return $(.gcc-current-snapshot-version) ;
}

rule get-gcc-previous-snapshot-version ( )
{
  .init-gcc-snapshot-aliases ;
  return $(.gcc-previous-snapshot-version) ;
}

rule get-gcc-oldest-snapshot-version ( )
{
  .init-gcc-snapshot-aliases ;
  return $(.gcc-oldest-snapshot-version) ;
}

rule get-clang-latest-version ( )
{
  if ! $(.clang-latest-version)
  {
    local clang-latest-version
      = [ SHELL "echo -n $(.clang-versions:J= ) | grep -Eo \"[[:digit:]]+\\.[[:digit:]]+\" | sort -u -t '.' -k 1,1n -k 2,2n | tail --lines=1 | tr --delete '\\n'" ] ;
    .clang-latest-version = $(clang-latest-version) ;
  }
  return $(.clang-latest-version) ;
}

rule is-valid ( compiler )
{
  local result ;
  if "$(compiler)" in gcc-current gcc-previous gcc-oldest gcc-snapshot gcc-current-snapshot gcc-previous-snapshot gcc-oldest-snapshot gcc-$(.gcc-versions)
  {
    result = yes ;
  }
  else if "$(compiler)" in clang-latest clang-trunk clang-$(.clang-versions)
  {
    result = yes ;
  }
  return $(result) ;
}

rule is-gcc ( compiler )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if "$(compiler)" in gcc-current gcc-previous gcc-oldest gcc-snapshot gcc-current-snapshot gcc-previous-snapshot gcc-oldest-snapshot gcc-$(.gcc-versions)
  {
    result = yes ;
  }
  return $(result) ;
}

rule is-builtin-gcc ( compiler )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if [ is-gcc $(compiler) ]
  {
    if [ get-version $(compiler) ] = [ SHELL "gcc -dumpversion | tr --delete '\\n'" ]
    {
      result = yes ;
    }
  }
  return $(result) ;
}

rule is-gcc-release ( compiler )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an invalid argument." ;
  }
  local result ;
  if $(compiler) in gcc-current gcc-previous gcc-oldest
  {
    result = yes ;
  }
  else if [ regex.match "^(gcc-[0-9]+\\.[0-9]+\\.[0-9]+)$" : $(compiler) : 1 ]
  {
    result = yes ;
  }
  return $(result) ;
}

rule is-gcc-snapshot ( compiler )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an invalid argument." ;
  }
  local result ;
  if $(compiler) in gcc-snapshot gcc-current-snapshot gcc-previous-snapshot gcc-oldest-snapshot
  {
    result = yes ;
  }
  else if [ regex.match "^(gcc-[0-9]+\\.[0-9]+(\\.0-RC)?-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9])$" : $(compiler) : 1 ]
  {
    result = yes ;
  }
  return $(result) ;
}

rule get-gccs ( compilers * )
{
  local result ;
  for local compiler in $(compilers)
  {
    if ! [ is-valid "$(compiler)" ]
    {
      errors.error "an internal error." ;
    }
    if [ is-gcc $(compiler) ]
    {
      result += $(compiler) ;
    }
  }
  return $(result) ;
}

rule get-gcc-versions ( compilers * )
{
  local result ;
  for local gcc in [ get-gccs $(compilers) ]
  {
    local version = [ get-version $(gcc) ] ;
    if ! $(version) in $(result)
    {
      result += $(version) ;
    }
  }
  return $(result) ;
}

rule get-version ( compiler )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if $(compiler) in gcc-current gcc-previous gcc-oldest gcc-snapshot gcc-current-snapshot gcc-previous-snapshot gcc-oldest-snapshot
  {
    result = [ get-$(compiler)-version ] ;
  }
  else if [ is-gcc $(compiler) ]
  {
    result = [ regex.match "gcc-(.+)" : $(compiler) : 1 ] ;
  }
  else if [ is-clang $(compiler) ]
  {
    if $(compiler) = clang-latest
    {
      result = [ get-clang-latest-version ] ;
    }
    else if $(compiler) = clang-trunk
    {
      errors.error "this rule cannot be called for Clang trunk." ;
    }
    else
    {
      result = [ regex.match "clang-(.+)" : $(compiler) : 1 ] ;
    }
  }
  else
  {
    errors.error "an internal error." ;
  }
  return $(result) ;
}

rule is-clang ( compiler )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if "$(compiler)" in clang-latest clang-trunk clang-$(.clang-versions)
  {
    result = yes ;
  }
  return $(result) ;
}

rule get-prefix-leaf ( compiler : gcc-for-clang ? )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if [ is-gcc $(compiler) ]
  {
    result = $(compiler) ;
  }
  else if [ is-clang $(compiler) ]
  {
    if ! $(gcc-for-clang)
    {
      errors.error "an internal error." ;
    }
    result = $(compiler)-$(gcc-for-clang) ;
  }
  else
  {
    errors.error "an internal error." ;
  }
  return $(result) ;
}

rule get-compiler-prefix ( prefix : compiler : gcc-for-clang ? )
{
  if ! [ is-valid $(compiler) ]
  {
    errors.error "an internal error" ;
  }
  if $(gcc-for-clang)
  {
    if ! [ is-valid $(gcc-for-clang) ]
    {
      errors.error "" ;
    }
  }
  local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
  return "$(prefix)/$(prefix-leaf)" ;
}

rule get-gcc-path ( prefix : compiler : gcc-for-clang ? )
{
  local result ;
  if [ is-gcc $(compiler) ]
  {
    if $(gcc-for-clang)
    {
      errors.error "an internal error." ;
    }
    local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
    local compiler-prefix = "$(prefix)/$(prefix-leaf)" ;
    result = "$(compiler-prefix)/bin/gcc-wrapper" ;
  }
  else if [ is-clang $(compiler) ]
  {
    if ! $(gcc-for-clang)
    {
      errors.error "an internal error." ;
    }
    local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
    local compiler-prefix = "$(prefix)/$(prefix-leaf)" ;
    result = "$(compiler-prefix)/bin/gcc-wrapper" ;
  }
  else
  {
    errors.error "`<compiler>$(compiler)' is not valid." ;
  }
  return $(result) ;
}

rule get-compiler-description ( compiler )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if [ is-gcc $(compiler) ]
  {
    local version = [ get-version $(compiler) ] ;
    result = "GCC $(version)" ;
  }
  else if [ is-clang $(compiler) ]
  {
    if $(compiler) = clang-trunk
    {
      result = "Clang trunk" ;
    }
    else
    {
      local version = [ get-version $(compiler) ] ;
      result = "Clang $(version)" ;
    }
  }
  else
  {
    errors.error "an internal error." ;
  }
  return $(result) ;
}

rule get-property-path ( properties * )
{
  local build                = [ feature.get-values <triplet>              : $(properties) ] ;
  local host                 = $(triplet) ;
  local compiler             = [ feature.get-values <compiler>             : $(properties) ] ;
  local std                  = [ feature.get-values <std>                  : $(properties) ] ;
  local address-model        ;
  local variant              = [ feature.get-values <variant>              : $(properties) ] ;
  local mudflap              = [ feature.get-values <mudflap>              : $(properties) ] ;
  local address-sanitizer    = [ feature.get-values <address-sanitizer>    : $(properties) ] ;
  local libstdcxx-debug-mode = [ feature.get-values <libstdc++-debug-mode> : $(properties) ] ;
  local result ;
  if $(build) = x86_64-unknown-linux-gnu && $(host) = i686-pc-linux-gnu
  {
    address-model = 32 ;
  }
  else if $(build) = x86_64-w64-mingw32 && $(host) = i686-w64-mingw32
  {
    address-model = 32 ;
  }
  if $(variant) = debug
  {
    result = debug ;
  }
  else if $(variant) = release
  {
    result = release ;
  }
  else if $(variant) = lto
  {
    result = lto ;
  }
  else
  {
    errors.error "`<variant>$(variant)' is not valid" ;
  }
  if $(address-model) = 32
  {
    result = $(result)/address-model-32 ;
  }
  if $(address-sanitizer) = off
  {
    # Do nothing.
  }
  else if $(address-sanitizer) = "on"
  {
    if ! [ is-clang $(compiler) ]
    {
      errors.error "`<address-sanitizer>on' is specified for non-Clang compiler `$(compiler)'" ;
    }
    result = $(result)/address-sanitizer-on ;
  }
  else
  {
    errors.error "`<address-sanitizer>$(address-sanitizer)' is not valid" ;
  }
  if $(libstdcxx-debug-mode) = off
  {
    # Do nothing.
  }
  else if $(libstdcxx-debug-mode) = "on"
  {
    result = $(result)/libstdc++-debug-mode-on ;
  }
  else
  {
    errors.error "`<libstdc++-debug-mode>$(libstdcxx-debug-mode)' is not valid" ;
  }
  if $(mudflap) = off
  {
    # Do nothing.
  }
  else if $(mudflap) = "on"
  {
    if ! [ is-gcc $(compiler) ]
    {
      errors.error "`<mudflap>on' is specified for non-GCC compiler `$(compiler)'" ;
    }
    result = $(result)/mudflap-on ;
  }
  else
  {
    errors.error "`<mudflap>$(mudflap)' is not valid" ;
  }
  if $(std) = c++11
  {
    result = $(result)/c++11 ;
  }
  return $(result) ;
}

rule get-bindir ( prefix : properties * : gcc-for-clang ? )
{
  local multitarget = [ feature.get-values <multitarget> : $(properties) ] ;
  local result = [ get-property-path $(properties) ] ;
  if $(multitarget) = yes
  {
    if [ regex.match "(/address-model-32)" : $(result) : 1 ]
    {
      result = [ regex.match "(.*)/address-model-32(.*)" : $(result) : 1 2 ] ;
      result = bin/32/$(result:J=) ;
    }
    else
    {
      result = bin/$(result) ;
    }
  }
  else
  {
    result = bin/$(result) ;
  }
  if [ regex.match "(/release)" : $(result) : 1 ]
  {
    result = [ regex.match "(.*)/release(.*)" : $(result) : 1 2 ] ;
    result = $(result:J=) ;
  }
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
  return $(prefix)/$(prefix-leaf)/$(result) ;
}

rule get-libdir ( prefix : properties * : gcc-for-clang ? )
{
  local multitarget = yes ; #[ feature.get-values <multitarget> : $(properties) ] ;
  local result = [ get-property-path $(properties) ] ;
  if $(multitarget) = yes
  {
    if [ regex.match "(/address-model-32)" : $(result) : 1 ]
    {
      result = [ regex.match "(.*)/address-model-32(.*)" : $(result) : 1 2 ] ;
      result = lib/$(result:J=) ;
    }
    else
    {
      result = lib64/$(result) ;
    }
  }
  else
  {
    result = lib/$(result) ;
  }
  if [ regex.match "(/release)" : $(result) : 1 ]
  {
    result = [ regex.match "(.*)/release(.*)" : $(result) : 1 2 ] ;
    result = $(result:J=) ;
  }
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
  return $(prefix)/$(prefix-leaf)/$(result) ;
}

rule get-includedir ( prefix : properties * : gcc-for-clang ? )
{
  local multitarget = [ feature.get-values <multitarget> : $(properties) ] ;
  local result = [ get-property-path $(properties) ] ;
  if $(multitarget) = yes
  {
    if [ regex.match "(/address-model-32)" : $(result) : 1 ]
    {
      result = [ regex.match "(.*)/address-model-32(.*)" : $(result) : 1 2 ] ;
      result = include/32/$(result:J=) ;
    }
    else
    {
      result = include/$(result) ;
    }
  }
  else
  {
    result = include/$(result) ;
  }
  if [ regex.match "(/release)" : $(result) : 1 ]
  {
    result = [ regex.match "(.*)/release(.*)" : $(result) : 1 2 ] ;
    result = $(result:J=) ;
  }
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
  return $(prefix)/$(prefix-leaf)/$(result) ;
}

rule get-cc ( prefix : properties * : gcc-for-clang ? )
{
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
  local compiler-prefix = "$(prefix)/$(prefix-leaf)" ;
  local result ;
  if ! [ is-builtin-gcc $(compiler) ]
  {
    if [ is-gcc $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/gcc-wrapper" ;
    }
    else if [ is-clang $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/clang-wrapper" ;
    }
    else
    {
      errors.error "an internal error." ;
    }
  }
  return "$(result)" ;
}

rule get-cflags ( properties * )
{
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local property-path = [ get-property-path $(properties) ] ;
  local result ;
  if [ regex.match "^(debug)" : $(property-path) : 1 ]
  {
    result += "-O0" ;
    result += "-g" ;
    result += "-fno-inline" ;
  }
  else if [ regex.match "^(release)" : $(property-path) : 1 ]
  {
    result += "-O3" ;
    result += "-finline-functions" ;
    result += "-Wno-inline" ;
    result += "-march=native" ;
  }
  else if [ regex.match "^(lto)" : $(property-path) : 1 ]
  {
    result += "-O3" ;
    result += "-finline-functions" ;
    result += "-Wno-inline" ;
    result += "-flto" ;
    result += "-march=native" ;
  }
  else
  {
    errors.error "an internal error" ;
  }
  if [ regex.match "(/mudflap-on)" : $(property-path) : 1 ]
  {
    if ! [ is-gcc $(compiler) ]
    {
      errors.error "`<mudflap>on' is specified for a compiler other than GCC" ;
    }
    errors.error "sorry, mudflap support has not been implemented yet" ;
  }
  if [ regex.match "(/address-sanitizer-on)" : $(property-path) : 1 ]
  {
    if ! [ is-clang $(compiler) ]
    {
      errors.error "`<address-sanitizer>on' is specified for non-Clang compiler" ;
    }
    result += "-faddress-sanitizer" ;
  }
  return "$(result:J= )" ;
}

rule get-cxx ( prefix : properties * : gcc-for-clang ? )
{
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local prefix-leaf = [ get-prefix-leaf "$(compiler)" : $(gcc-for-clang) ] ;
  local compiler-prefix = "$(prefix)/$(prefix-leaf)" ;
  local result ;
  if ! [ is-builtin-gcc $(compiler) ]
  {
    if [ is-gcc $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/g++-wrapper" ;
    }
    else if [ is-clang $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/clang++-wrapper" ;
    }
    else
    {
      errors.error "an internal error." ;
    }
  }
  return "$(result)" ;
}

rule get-cxxflags ( properties * )
{
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local property-path = [ get-property-path $(properties) ] ;
  local result ;
  if [ regex.match "^(debug)" : $(property-path) : 1 ]
  {
    result += "-O0" ;
    result += "-g" ;
    result += "-fno-inline" ;
  }
  else if [ regex.match "^(release)" : $(property-path) : 1 ]
  {
    result += "-O3" ;
    result += "-finline-functions" ;
    result += "-Wno-inline" ;
    result += "-march=native" ;
  }
  else if [ regex.match "^(lto)" : $(property-path) : 1 ]
  {
    result += "-O3" ;
    result += "-finline-functions" ;
    result += "-Wno-inline" ;
    result += "-flto" ;
    result += "-march=native" ;
  }
  else
  {
    errors.error "an internal error" ;
  }
  if [ regex.match "(/c\\+\\+11)" : $(property-path) : 1 ]
  {
    result += "-std=c++0x" ;
  }
  else
  {
    result += "-std=c++03" ;
  }
  if [ regex.match "(/mudflap-on)" : $(property-path) : 1 ]
  {
    if ! [ is-gcc $(compiler) ]
    {
      errors.error "`<mudflap>on' is specified for a compiler other than GCC" ;
    }
    errors.error "sorry, mudflap support has not been implemented yet" ;
  }
  if [ regex.match "(/address-sanitizer-on)" : $(property-path) : 1 ]
  {
    if ! [ is-clang $(compiler) ]
    {
      errors.error "`<address-sanitizer>on' is specified for a compiler other than Clang" ;
    }
    result += "-faddress-sanitizer" ;
  }
  if [ regex.match "(/libstdc\\+\\+-debug-mode-on)" : $(property-path) : 1 ]
  {
    result += "-D_GLIBCXX_DEBUG" ;
    result += "-D_GLIBCXX_DEBUG_PEDANTIC" ;
  }
  return "$(result:J= )" ;
}

rule get-toolset ( compiler : gcc-for-clang ? )
{
  errors.error "deprecated" ;

  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if [ is-gcc $(compiler) ]
  {
    local version = [ get-version "$(compiler)" ] ;
    version = [ regex.replace $(version) "-" "_" ] ;
    result = gcc-$(version) ;
  }
  else if [ is-clang $(compiler) ]
  {
    if ! [ is-valid "$(gcc-for-clang)" ]
    {
      errors.error "an internal error." ;
    }
    local gcc-version = [ get-version $(gcc-for-clang) ] ;
    gcc-version = [ regex.replace $(gcc-version) "-" "_" ] ;
    local clang-version = [ get-version $(compiler) ] ;
    clang-version = [ regex.replace $(clang-version) "-" "_" ] ;
    result = gcc-$(gcc-version)_$(clang-version) ;
  }
  return $(result) ;
}

rule get-abi-tag ( compiler : gcc-for-clang ? )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local result ;
  if [ is-gcc $(compiler) ]
  {
    local version = [ get-version $(compiler) ] ;
    local abi-version = [ regex.match "^([0-9]+\\.[0-9]+)" : $(version) : 1 ] ;
    local version-tag = [ regex.replace $(abi-version) "\\." "" ] ;
    result = gcc$(version-tag) ;
  }
  else if [ is-clang $(compiler) ]
  {
    if ! [ is-valid "$(gcc-for-clang)" ]
    {
      errors.error "an internal error." ;
    }
    local version = [ get-version $(gcc-for-clang) ] ;
    local abi-version = [ regex.match "^([0-9]+\\.[0-9]+)" : $(version) : 1 ] ;
    local version-tag = [ regex.replace $(abi-version) "\\." "" ] ;
    result = gcc$(version-tag) ;
  }
  return $(result) ;
}

rule cc ( prefix : compiler : gcc-for-clang ? )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local prefix-leaf = [ get-prefix-leaf "$(compiler)" : $(gcc-for-clang) ] ;
  local compiler-prefix = "$(prefix)/$(prefix-leaf)" ;
  local result ;
  if ! [ is-builtin-gcc $(compiler) ]
  {
    if [ is-gcc $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/gcc-wrapper" ;
    }
    else if [ is-clang $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/clang-wrapper" ;
    }
    else
    {
      errors.error "an internal error." ;
    }
  }
  return [ path.native "$(result)" ] ;
}

rule cxx ( prefix : compiler : gcc-for-clang ? )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local prefix-leaf = [ get-prefix-leaf "$(compiler)" : $(gcc-for-clang) ] ;
  local compiler-prefix = "$(prefix)/$(prefix-leaf)" ;
  local result ;
  if ! [ is-builtin-gcc $(compiler) ]
  {
    if [ is-gcc $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/g++-wrapper" ;
    }
    else if [ is-clang $(compiler) ]
    {
      result = "$(compiler-prefix)/bin/clang++-wrapper" ;
    }
    else
    {
      errors.error "an internal error." ;
    }
  }
  return [ path.native "$(result)" ] ;
}

rule get-environment-commands ( prefix : properties * : gcc-for-clang ? )
{
  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local compiler-prefix = [ get-compiler-prefix "$(prefix)" : $(compiler) : $(gcc-for-clang) ] ;
  local is-debug ;
  if [ feature.get-values <variant> : $(properties) ] = debug
  {
    is-debug = yes ;
  }
  local default-bindir = "$(compiler-prefix)/bin" ;
  local bindir = [ get-bindir $(prefix) : $(properties) : $(gcc-for-clang) ] ;
  local libdir = [ get-libdir $(prefix) : $(properties) : $(gcc-for-clang) ] ;
  local default-libdir ;
  if [ regex.match "(/lib64)" : "$(libdir)" : 1 ]
  {
    default-libdir = "$(compiler-prefix)/lib64" ;
  }
  else
  {
    default-libdir = "$(compiler-prefix)/lib" ;
  }
  local default-debug-libdir ;
  if $(is-debug)
  {
    default-debug-libdir = "$(default-libdir)/debug" ;
  }
  local includedir = [ get-includedir $(prefix) : $(properties) : $(gcc-for-clang) ] ;
  local commands ;
  if $(build) in x86_64-unknown-linux-gnu i686-pc-linux-gnu
  {
    commands += "PATH=\"$(default-bindir)${PATH:+:$PATH}\"" ;
    commands += "export PATH" ;
    commands += "LD_LIBRARY_PATH=\"$(default-libdir)${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}\"" ;
    if $(is-debug) && "$(default-debug-libdir)" != "$(default-libdir)"
    {
      commands += "LD_LIBRARY_PATH=\"$(default-debug-libdir):$LD_LIBRARY_PATH\"" ;
    }
    if "$(libdir)" != "$(default-libdir)" && "$(libdir)" != "$(default-debug-libdir)"
    {
      commands += "LD_LIBRARY_PATH=\"$(libdir):$LD_LIBRARY_PATH\"" ;
    }
    commands += "export LD_LIBRARY_PATH" ;
  }
  else if $(build) in x86_64-w64-mingw32 i686-w64-mingw32 i686-pc-cygwin
  {
    commands += "PATH=\"$(libdir)\;$(bindir)\$\{PATH\:\+\;\$PATH}\"" ;
    commands += "export PATH" ;
  }
  else
  {
    errors.error "`<build>$(build)' is not valid" ;
  }
  commands += "CPATH=\"$(includedir)${CPATH:+:$CPATH}\"" ;
  commands += "export CPATH" ;
  commands += "LIBRARY_PATH=\"$(libdir)${LIBRARY_PATH:+:$LIBRARY_PATH}\"" ;
  commands += "export LIBRARY_PATH" ;
  commands = "$(commands:J=\n)" ;
  return "$(commands)" ;
}

rule prepend-shared-library-path-variable-command ( prefix : compiler : gcc-for-clang ? )
{
  if ! [ is-valid "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local prefix-leaf = [ get-prefix-leaf $(compiler) : $(gcc-for-clang) ] ;
  local compiler-prefix = "$(prefix)/$(prefix-leaf)" ;
  local shared-library-path ;
  if [ os.on-windows ]
  {
    shared-library-path = "$(compiler-prefix)/bin" ;
  }
  else
  {
    shared-library-path = "$(compiler-prefix)/lib64" ;
  }
  shared-library-path = [ path.native "$(shared-library-path)" ] ;
  return [ common.prepend-path-variable-command [ os.shared-library-path-variable ] : "$(shared-library-path)" ] ;
}
