project site-config ;

import common ;
import errors ;
import feature ;
import modules ;
import path ;
import property ;
import property-set ;
import python ;
import regex ;

local home = [ modules.peek : HOME ] ;

# Modify the following lines.
local prefix = "$(home)/local" ;
local boost-root = "$(prefix)/boost" ;


local ver-prefixes ;
local gcc-paths ;
local gcc-latest-paths ;
local clang-paths ;
local clang-latest-paths ;
local icc-paths ;
local icc-latest-paths ;

rule get-gcc-path ( ph )
{
  local tmp = [ SHELL "[ -x \"$(ph)/bin/g++-wrapper\" ] && env LANG=C \"$(ph)/bin/g++-wrapper\" --version | head --lines=1" ] ;
  local ver-date = [ regex.match "([0-9]+\\.[0-9]+\\.[0-9]+) ([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]) \\(((experimental)|(prerelease))\\)" : "$(tmp)" : 1 2 ] ;
  local result ;
  if $(ver-date[1]) && $(ver-date[2]) {
    local timestamp = [ SHELL "env LANG=C ls --full-time \"$(ph)/bin/g++-wrapper\" | tr --squeeze-repeats ' ' | cut --delimiter=' ' --fields=6,7,8 | date --file=- +%Y%m%d%H%M%S | tr --delete '\\n'" ] ;
    result  = "$(ph)/bin/g++-wrapper" ;
    result += $(ver-date[1]) ;
    result += $(ver-date[2]) ;
    result += $(timestamp) ;
  }
  else {
    local ver = [ regex.match "([0-9]+\\.[0-9]+\\.[0-9]+)" : "$(tmp)" : 1 ] ;
    if $(ver) {
      local timestamp = [ SHELL "env LANG=C ls --full-time \"$(ph)/bin/g++-wrapper\" | tr --squeeze-repeats ' ' | cut --delimiter=' ' --fields=6,7,8 | date --file=- +%Y%m%d%H%M%S | tr --delete '\\n'" ] ;
      result  = "$(ph)/bin/g++-wrapper" ;
      result += $(ver) ;
      result += 99999999 ;
      result += $(timestamp) ;
    }
  }
  return $(result) ;
}

rule get-clang-path ( ph )
{
  local tmp = [ SHELL "[ -x \"$(ph)/bin/clang++-wrapper\" ] && env LANG=C \"$(ph)/bin/clang++-wrapper\" --version | head --lines=1" ] ;
  local ver-rev = [ regex.match "^clang version ([0-9]+\\.[0-9]+) \\(trunk ([0-9]+)\\)" : "$(tmp)" : 1 2 ] ;
  local result ;
  if $(ver-rev[1]) && $(ver-rev[2]) {
    local timestamp = [ SHELL "env LANG=C ls --full-time \"$(ph)/bin/clang++-wrapper\" | tr --squeeze-repeats ' ' | cut --delimiter=' ' --fields=6,7,8 | date --file=- +%Y%m%d%H%M%S | tr --delete '\\n'" ] ;
    result  = "$(ph)/bin/clang++-wrapper" ;
    result += $(ver-rev[1]) ;
    result += $(ver-rev[2]) ;
    result += $(timestamp) ;
  }
  else {
    local ver = [ regex.match "([0-9]+\\.[0-9]+)" : "$(tmp)" : 1 ] ;
    if $(ver) {
      local timestamp = [ SHELL "env LANG=C ls --full-time \"$(ph)/bin/clang++-wrapper\" | tr --squeeze-repeats ' ' | cut --delimiter=' ' --fields=6,7,8 | date --file=- +%Y%m%d%H%M%S | tr --delete '\\n'" ] ;
      result  = "$(ph)/bin/clang++-wrapper" ;
      result += $(ver) ;
      result += 99999999 ;
      result += $(timestamp) ;
    }
  }
  return $(result) ;
}

rule get-icc-path ( ph )
{
  local tmp = [ SHELL "[ -x \"$(ph)/bin/icpc-wrapper\" ] && env LANG=C \"$(ph)/bin/icpc-wrapper\" --version | head --lines=1" ] ;
  local ver = [ regex.match "^icpc \\(ICC\\) ([0-9]+\\.[0-9]+\\.[0-9]+)" : "$(tmp)" : 1 ] ;
  local result ;
  if $(ver) {
    local timestamp = [ SHELL "env LANG=C ls --full-time \"$(ph)/bin/icpc-wrapper\" | tr --squeeze-repeats ' ' | cut --delimiter=' ' --fields=6,7,8 | date --file=- +%Y%m%d%H%M%S | tr --delete '\\n'" ] ;
    result  = "$(ph)/bin/icpc-wrapper" ;
    result += $(ver) ;
    result += $(timestamp) ;
  }
  return $(result) ;
}

{
  local gcc-vers ;
  local clang-vers ;
  local icc-vers ;

  for local ver-prefix in [ path.glob "$(prefix)" : * ] {
    if [ regex.match "^($(prefix)/gcc-)" : "$(ver-prefix)" : 1 ] {
      local gcc-path = [ get-gcc-path "$(ver-prefix)" ] ;
      if $(gcc-path) {
        if ! "$(ver-prefix)" in "$(ver-prefixes)" {
          ver-prefixes += "$(ver-prefix)" ;
        }
        local ver = $(gcc-path[2]) ;
        if ! $(ver) in $(gcc-vers) {
          gcc-vers += $(ver) ;
        }
        gcc-paths += "$(gcc-path:J=,)" ;
      }
    }

    if [ regex.match "^($(prefix)/clang-)" : "$(ver-prefix)" : 1 ] {
      local gcc-path = [ get-gcc-path "$(ver-prefix)" ] ;
      local clang-path = [ get-clang-path "$(ver-prefix)" ] ;
      if $(gcc-path) && $(clang-path) {
        if ! "$(ver-prefix)" in "$(ver-prefixes)" {
          ver-prefixes += "$(ver-prefix)" ;
        }
        local clang-ver = $(clang-path[2]) ;
        if ! $(clang-ver) in $(clang-vers) {
          clang-vers += $(clang-ver) ;
        }
        clang-paths += "$(ver-prefix)/bin/clang++-wrapper",$(gcc-path[2]),$(gcc-path[3]),$(gcc-path[4]),$(clang-path[2]),$(clang-path[3]),$(clang-path[4]) ;
      }
    }

    if [ regex.match "^($(prefix)/icc-)" : "$(ver-prefix)" : 1 ] {
      local gcc-path = [ get-gcc-path "$(ver-prefix)" ] ;
      local icc-path = [ get-icc-path "$(ver-prefix)" ] ;
      if $(gcc-path) && $(icc-path) {
        if ! "$(ver-prefix)" in "$(ver-prefixes)" {
          ver-prefixes += "$(ver-prefix)" ;
        }
        local icc-ver = $(icc-path[2]) ;
        if ! $(icc-ver) in $(icc-vers) {
          icc-vers += $(icc-ver) ;
        }
        icc-paths += "$(ver-prefix)/bin/icpc-wrapper",$(gcc-path[2]),$(gcc-path[3]),$(gcc-path[4]),$(icc-path[2]),$(icc-path[3]) ;
      }
    }
  }
  #ECHO ver-prefixes: $(ver-prefixes:J=,) ;
  #ECHO gcc-vers: $(gcc-vers:J=,) ;
  #ECHO clang-vers: $(clang-vers:J=,) ;
  #ECHO icc-vers: $(icc-vers:J=,) ;
  #ECHO gcc-paths: $(gcc-paths:J=;) ;
  #ECHO clang-paths: $(clang-paths:J=;) ;
  #ECHO icc-paths: $(icc-paths:J=;) ;
  #ECHO "" ;
  #errors.error "" ;

  for local gcc-ver in $(gcc-vers) {
    local latest-path ;
    local latest-rev ;
    local latest-timestamp ;
    for local gcc-path in $(gcc-paths) {
      local ph ;
      local ver ;
      local rev ;
      local timestamp ;
      {
        local tmp = [ regex.split "$(gcc-path)" "," ] ;
        ph = "$(tmp[1])" ;
        ver = $(tmp[2]) ;
        rev = $(tmp[3]) ;
        timestamp = $(tmp[4]) ;
      }
      if ! $(ph) || ! $(ver) || ! $(rev) || ! $(timestamp) {
        errors.error "an internal error." ;
      }
      if $(ver) = $(gcc-ver) {
        if ! $(latest-path) && ! $(latest-rev) && ! $(latest-timestamp) {
          latest-path      = "$(ph)" ;
          latest-rev       = $(rev) ;
          latest-timestamp = $(timestamp) ;
        }
        else {
          if $(rev) > $(latest-rev) {
            latest-path      = "$(ph)" ;
            latest-rev       = $(rev) ;
            latest-timestamp = $(timestamp) ;
          }
          else if $(rev) = $(latest-rev) {
            if $(timestamp) > $(latest-timestamp) {
              latest-path      = "$(ph)" ;
              latest-rev       = $(rev) ;
              latest-timestamp = $(timestamp) ;
            }
          }
        }
      }
    }

    if ! $(latest-path) || ! $(latest-rev) || ! $(latest-timestamp) {
      errors.error "an internal error." ;
    }

    gcc-latest-paths += "$(latest-path)",$(gcc-ver),$(latest-rev),$(latest-timestamp) ;
  }

  for local clang-ver in $(clang-vers) {
    local latest-path ;
    local latest-gcc-ver ;
    local latest-gcc-date ;
    local latest-gcc-timestamp ;
    local latest-clang-rev ;
    local latest-clang-timestamp ;
    for local clang-path in $(clang-paths) {
      #ECHO clang-path: $(clang-path) ;
      local ph ;
      local gcc-ver ;
      local gcc-date ;
      local gcc-timestamp ;
      local ver ;
      local clang-rev ;
      local clang-timestamp ;
      {
        local tmp = [ regex.split "$(clang-path)" "," ] ;
        ph               = "$(tmp[1])" ;
        gcc-ver          = $(tmp[2]) ;
        gcc-date         = $(tmp[3]) ;
        gcc-timestamp    = $(tmp[4]) ;
        ver              = $(tmp[5]) ;
        clang-rev        = $(tmp[6]) ;
        clang-timestamp  = $(tmp[7]) ;
      }
      if ! $(ph) || ! $(gcc-ver) || ! $(gcc-date) || ! $(gcc-timestamp) || ! $(ver) || ! $(clang-rev) || ! $(clang-timestamp) {
        errors.error "an internal error." ;
      }
      if $(ver) = $(clang-ver) {
        local is-latest ;
        if ! $(latest-path) {
          if $(latest-gcc-ver) || $(latest-gcc-date) || $(latest-gcc-timestamp) || $(latest-clang-rev) || $(latest-clang-timestamp) {
            errors.error "an internal error." ;
          }
          is-latest = yes ;
        }
        else {
          if $(gcc-ver) > $(latest-gcc-ver) {
            is-latest = yes ;
          }
          else if $(gcc-date) = $(latest-gcc-date) {
            if $(gcc-date) > $(latest-gcc-date) {
              is-latest = yes ;
            }
            else if $(gcc-date) = $(latest-gcc-date) {
              if $(gcc-timestamp) > $(latest-gcc-timestamp) {
                is-latest = yes ;
              }
              else if $(gcc-timestamp) = $(latest-gcc-timestamp) {
                if $(clang-rev) > $(latest-clang-rev) {
                  is-latest = yes ;
                }
                else if $(clang-rev) = $(latest-clang-rev) {
                  if $(clang-timestamp) > $(latest-clang-timestamp) {
                    is-latest = yes ;
                  }
                }
              }
            }
          }
        }
        if $(is-latest) {
          latest-path            = "$(ph)" ;
          latest-gcc-ver         = $(gcc-ver) ;
          latest-gcc-date        = $(gcc-date) ;
          latest-gcc-timestamp   = $(gcc-timestamp) ;
          latest-clang-rev       = $(clang-rev) ;
          latest-clang-timestamp = $(clang-timestamp) ;
        }
      }
    }

    if ! $(latest-path) || ! $(latest-gcc-ver) || ! $(latest-gcc-date) || ! $(latest-gcc-timestamp) || ! $(latest-clang-rev) || ! $(latest-clang-timestamp) {
      ECHO latest-path: $(latest-path) ;
      ECHO latest-gcc-ver: $(latest-gcc-ver) ;
      ECHO latest-gcc-date: $(latest-gcc-date) ;
      ECHO latest-gcc-timestamp: $(latest-gcc-timestamp) ;
      ECHO latest-clang-rev: $(latest-clang-rev) ;
      ECHO latest-clnag-timestamp: $(latest-clang-timestamp) ;
      errors.error "an internal error." ;
    }

    clang-latest-paths += "$(latest-path)",$(latest-gcc-ver),$(latest-gcc-date),$(latest-gcc-timestamp),$(clang-ver),$(latest-clang-rev),$(latest-clang-timestamp) ;
  }

  for local icc-ver in $(icc-vers) {
    local latest-path ;
    local latest-gcc-ver ;
    local latest-gcc-date ;
    local latest-gcc-timestamp ;
    local latest-icc-timestamp ;
    for local icc-path in $(icc-paths) {
      #ECHO icc-path: $(icc-path) ;
      local ph ;
      local gcc-ver ;
      local gcc-date ;
      local gcc-timestamp ;
      local ver ;
      local icc-timestamp ;
      {
        local tmp = [ regex.split "$(icc-path)" "," ] ;
        ph               = "$(tmp[1])" ;
        gcc-ver          = $(tmp[2]) ;
        gcc-date         = $(tmp[3]) ;
        gcc-timestamp    = $(tmp[4]) ;
        ver              = $(tmp[5]) ;
        icc-timestamp  = $(tmp[6]) ;
      }
      if ! $(ph) || ! $(gcc-ver) || ! $(gcc-date) || ! $(gcc-timestamp) || ! $(ver) || ! $(icc-timestamp) {
        errors.error "an internal error." ;
      }
      if $(ver) = $(icc-ver) {
        local is-latest ;
        if ! $(latest-path) {
          if $(latest-gcc-ver) || $(latest-gcc-date) || $(latest-gcc-timestamp) || $(latest-icc-timestamp) {
            errors.error "an internal error." ;
          }
          is-latest = yes ;
        }
        else {
          if $(gcc-ver) > $(latest-gcc-ver) {
            is-latest = yes ;
          }
          else if $(gcc-date) = $(latest-gcc-date) {
            if $(gcc-date) > $(latest-gcc-date) {
              is-latest = yes ;
            }
            else if $(gcc-date) = $(latest-gcc-date) {
              if $(gcc-timestamp) > $(latest-gcc-timestamp) {
                is-latest = yes ;
              }
              else if $(gcc-timestamp) = $(latest-gcc-timestamp) {
                if $(icc-timestamp) > $(latest-icc-timestamp) {
                  is-latest = yes ;
                }
              }
            }
          }
        }
        if $(is-latest) {
          latest-path          = "$(ph)" ;
          latest-gcc-ver       = $(gcc-ver) ;
          latest-gcc-date      = $(gcc-date) ;
          latest-gcc-timestamp = $(gcc-timestamp) ;
          latest-icc-timestamp = $(icc-timestamp) ;
        }
      }
    }

    if ! $(latest-path) || ! $(latest-gcc-ver) || ! $(latest-gcc-date) || ! $(latest-gcc-timestamp) || ! $(latest-icc-timestamp) {
      ECHO latest-path: $(latest-path) ;
      ECHO latest-gcc-ver: $(latest-gcc-ver) ;
      ECHO latest-gcc-date: $(latest-gcc-date) ;
      ECHO latest-gcc-timestamp: $(latest-gcc-timestamp) ;
      ECHO latest-icc-timestamp: $(latest-icc-timestamp) ;
      errors.error "an internal error." ;
    }

    icc-latest-paths += "$(latest-path)",$(latest-gcc-ver),$(latest-gcc-date),$(latest-gcc-timestamp),$(icc-ver),$(latest-icc-timestamp) ;
  }
}

{
  local gcc-paths-tmp ;
  for local gcc-path in $(gcc-paths) {
    gcc-path = [ regex.split "$(gcc-path)" "," ] ;
    local ver = [ regex.match "^([0-9]+\\.[0-9]+)\\.[0-9]+$" : $(gcc-path[2]) : 1 ] ;
    if $(gcc-path[3]) != 99999999 {
      gcc-paths-tmp += "$(gcc-path[1])",$(ver)_$(gcc-path[3]) ;
      if [ SHELL "[ -x \"$(gcc-path[1]:D)/clang++-wrapper\" ] && echo -n SUCCESS" ] = SUCCESS {
        gcc-paths-tmp += "$(gcc-path[1]:D)/clang++-wrapper",$(ver)_$(gcc-path[3])_clang ;
      }
    }
  }
  gcc-paths = $(gcc-paths-tmp) ;
}

{
  local gcc-latest-paths-tmp ;
  for local gcc-latest-path in $(gcc-latest-paths) {
    gcc-latest-path = [ regex.split "$(gcc-latest-path)" "," ] ;
    gcc-latest-paths-tmp += "$(gcc-latest-path[1])",$(gcc-latest-path[2]) ;
    if [ SHELL "[ -x \"$(gcc-latest-path[1]:D)/clang++-wrapper\" ] && echo -n SUCCESS" ] = SUCCESS {
      gcc-latest-paths-tmp += "$(gcc-latest-path[1]:D)/clang++-wrapper",$(gcc-latest-path[2])_clang ;
    }
  }
  gcc-latest-paths = $(gcc-latest-paths-tmp) ;
}

{
  local clang-paths-tmp ;
  for local clang-path in $(clang-paths) {
    clang-path = [ regex.split "$(clang-path)" "," ] ;
    local ver ;
    if $(clang-path[3]) = 99999999 {
      ver = $(clang-path[2]) ;
    }
    else {
      ver = [ regex.match "^([0-9]+\\.[0-9]+)\\.[0-9]+$" : $(clang-path[2]) : 1 ] ;
      ver = $(ver)_$(clang-path[3]) ;
    }
    if $(clang-path[6]) != 99999999 {
      clang-paths-tmp += "$(clang-path[1])",$(ver)_$(clang-path[5])_$(clang-path[6]) ;
    }
  }
  clang-paths = $(clang-paths-tmp) ;
}

{
  local clang-latest-paths-tmp ;
  for local clang-latest-path in $(clang-latest-paths) {
    clang-latest-path = [ regex.split "$(clang-latest-path)" "," ] ;
    local ver ;
    if $(clang-latest-path[3]) = 99999999 {
      ver = $(clang-latest-path[2]) ;
    }
    else {
      ver = [ regex.match "^([0-9]+\\.[0-9]+)\\.[0-9]+$" : $(clang-latest-path[2]) : 1 ] ;
      ver = $(ver)_$(clang-latest-path[3]) ;
    }
    ver = $(ver)_$(clang-latest-path[5]) ;
    clang-latest-paths-tmp += "$(clang-latest-path[1])",$(ver) ;
  }
  clang-latest-paths = $(clang-latest-paths-tmp) ;
}

{
  local icc-paths-tmp ;
  for local icc-path in $(icc-paths) {
    icc-path = [ regex.split "$(icc-path)" "," ] ;
    local ver ;
    if $(icc-path[3]) = 99999999 {
      ver = $(icc-path[2]) ;
    }
    else {
      ver = [ regex.match "^([0-9]+\\.[0-9]+)\\.[0-9]+$" : $(icc-path[2]) : 1 ] ;
      ver = $(ver)_$(icc-path[3]) ;
    }
    icc-paths-tmp += "$(icc-path[1])",$(icc-path[5])_$(ver) ;
  }
  icc-paths = $(icc-paths-tmp) ;
}

{
  local icc-latest-paths-tmp ;
  for local icc-latest-path in $(icc-latest-paths) {
    icc-latest-path = [ regex.split "$(icc-latest-path)" "," ] ;
    icc-latest-paths-tmp += "$(icc-latest-path[1])",$(icc-latest-path[5]) ;
  }
  icc-latest-paths = $(icc-latest-paths-tmp) ;
}

if $(gcc-paths) {
  constant INTRO_GCC_PATHS : $(gcc-paths) ;
}
if $(gcc-latest-paths) {
  constant INTRO_GCC_LATEST_PATHS : $(gcc-latest-paths) ;
}
if $(clang-paths) {
  constant INTRO_CLANG_PATHS : $(clang-paths) ;
}
if $(clang-latest-paths) {
  constant INTRO_CLANG_LATEST_PATHS : $(clang-latest-paths) ;
}
if $(icc-paths) {
  constant INTRO_ICC_PATHS : $(icc-paths) ;
}
if $(icc-latest-paths) {
  constant INTRO_ICC_LATEST_PATHS : $(icc-latest-paths) ;
}

#ECHO INTRO_GCC_PATHS: $(INTRO_GCC_PATHS) ;
#ECHO INTRO_GCC_LATEST_PATHS: $(INTRO_GCC_LATEST_PATHS) ;
#ECHO INTRO_CLANG_PATHS: $(INTRO_CLANG_PATHS) ;
#ECHO INTRO_CLANG_LATEST_PATHS: $(INTRO_CLANG_LATEST_PATHS) ;
#ECHO INTRO_ICC_PATHS: $(INTRO_ICC_PATHS) ;
#ECHO INTRO_ICC_LATEST_PATHS: $(INTRO_ICC_LATEST_PATHS) ;
#ECHO "" ;
#errors.error "****************************************" ;



#############################################################################



feature.extend instruction-set
  : generic
  ;

feature.feature std
  : c++03 c++11
  : propagated
  ;
constant INTRO_STD_COMPILE_PROPERTIES
  : <toolset>gcc,<std>c++03:<cxxflags>-std=c++03
    <toolset>gcc,<std>c++11:<cxxflags>-std=c++0x
    <toolset>clang,<std>c++03:<cxxflags>-std=c++03
    <toolset>clang,<std>c++11:<cxxflags>-std=c++11
    <toolset>intel,<std>c++03:<cxxflags>"-strict-ansi -fno-math-errno"
    <toolset>intel,<std>c++11:<cxxflags>-std=c++11
  ;

feature.feature lto
  : off on
  : propagated
  ;
constant INTRO_LTO_COMPILE_PROPERTIES
  : <toolset>gcc,<lto>on:<cflags>-flto
    <toolset>clang,<lto>on:<cflags>-flto
    <toolset>intel,<lto>on:<cflags>-ipo
  ;
constant INTRO_LTO_LINK_PROPERTIES
  : <toolset>gcc,<lto>on:<linkflags>-flto
    <toolset>gcc,<lto>on,<link>shared:<linkflags>-fPIC
    <toolset>gcc,<lto>on,<optimization>speed:<linkflags>-O3
    <toolset>gcc,<lto>on,<optimization>space:<linkflags>-Os
    <toolset>gcc,<lto>on,<inlining>off:<linkflags>-fno-inline
    <toolset>gcc,<lto>on,<inlining>on:<linkflags>-Wno-inline
    <toolset>gcc,<lto>on,<inlining>full:<linkflags>"-finline-functions -Wno-inline"
    <toolset>clang,<lto>on:<linkflags>-flto
    <toolset>clang,<lto>on,<link>shared:<linkflags>-fPIC
    <toolset>clang,<lto>on,<optimization>speed:<linkflags>-O3
    <toolset>clang,<lto>on,<optimization>space:<linkflags>-Os
    <toolset>clang,<lto>on,<inlining>off:<linkflags>-fno-inline
    <toolset>clang,<lto>on,<inlining>on:<linkflags>-Wno-inline
    <toolset>clang,<lto>on,<inlining>full:<linkflags>"-finline-functions -Wno-inline"
    <toolset>intel,<lto>on:<linkflags>-ipo
    <toolset>intel,<lto>on,<link>shared:<linkflags>-fPIC
    <toolset>intel,<lto>on,<optimization>speed:<linkflags>-O3
    <toolset>intel,<lto>on,<optimization>space:<linkflags>-Os
    <toolset>intel,<lto>on,<inlining>off:<linkflags>-inline-level=0
    <toolset>intel,<lto>on,<inlining>on:<linkflags>"-inline-level=1 -Wno-inline"
    <toolset>intel,<lto>on,<inlining>full:<linkflags>"-inline-level=2 -Wno-inline"
  ;

feature.feature correct-call-stack
  : off on
  : propagated composite
  ;
feature.compose <correct-call-stack>on
  : <cflags>"-fno-omit-frame-pointer -fno-optimize-sibling-calls"
    <linkflags>"-fno-omit-frame-pointer -fno-optimize-sibling-calls"
  ;

feature.feature ssp
  : off on all
  : propagated composite
  ;
feature.compose <ssp>on
  : <cflags>-fstack-protector
    <linkflags>-fstack-protector
  ;
feature.compose <ssp>all
  : <cflags>-fstack-protector-all
    <linkflags>-fstack-protector-all
  ;
constant INTRO_SSP_COMPILE_PROPERTIES
  : <toolset>intel,<ssp>on:<cflags>-fstack-security-check
    <toolset>intel,<ssp>all:<cflags>-fstack-security-check
  ;
constant INTRO_SSP_LINK_PROPERTIES
  : <toolset>intel,<ssp>on:<linkflags>-fstack-security-check
    <toolset>intel,<ssp>all:<linkflags>-fstack-security-check
  ;

feature.feature memory-checker
  : off on
  : propagated
  ;
constant INTRO_MEMORY_CHECKER_COMPILE_PROPERTIES
  : <toolset>gcc,<memory-checker>on:<cflags>"-fsanitize=address"
    <toolset>clang,<memory-checker>on:<cflags>"-fsanitize=address"
    <toolset>intel,<memory-checker>on:<cflags>"-fp-speculation safe -ftrapuv -check-pointers=rw -check-pointers-dangling=all -check-pointers-undimensioned"
  ;
constant INTRO_MEMORY_CHECKER_LINK_PROPERTIES
  : <toolset>gcc,<memory-checker>on:<linkflags>"-fsanitize=address"
    <toolset>clang,<memory-checker>on:<linkflags>"-fsanitize=address"
    <toolset>intel,<memory-checker>on:<linkflags>"-fp-speculation safe -ftrapuv -check-pointers=rw -check-pointers-dangling=all -check-pointers-undimensioned"
  ;

feature.feature libstdc++-debug-mode
  : off on
  : propagated composite
  ;
feature.compose <libstdc++-debug-mode>on
  : <define>_GLIBCXX_DEBUG
    <define>_GLIBCXX_DEBUG_PEDANTIC
  ;

feature.feature memcheck
  : off on
  : propagated incidental
  ;
feature.feature memcheck-run
  : off on
  ;

feature.feature catchsegv
  : off on
  : propagated incidental
  ;
feature.feature catchsegv-run
  : off on
  ;

constant INTRO_COMPILE_PROPERTIES
  : <exception-handling>off:<cflags>-fno-exceptions
    <rtti>off:<linkflags>-fno-rtti
    <toolset>gcc,<variant>debug:<cflags>-g3
    <toolset>intel,<variant>debug:<cflags>"-debug full"
    <toolset>intel,<instruction-set>native:<cflags>"-xHost"
    $(INTRO_STD_COMPILE_PROPERTIES)
    $(INTRO_LTO_COMPILE_PROPERTIES)
    $(INTRO_SSP_COMPILE_PROPERTIES)
    $(INTRO_MEMORY_CHECKER_COMPILE_PROPERTIES)
  ;

constant INTRO_LINK_PROPERTIES
  : <exception-handling>off:<linkflags>-fno-exceptions
    <rtti>off:<linkflags>-fno-rtti
    <toolset>gcc,<variant>debug:<linkflags>-g3
    <toolset>intel,<variant>debug:<linkflags>"-debug full"
    <variant>debug:<linkflags>-rdynamic
    <variant>profile:<linkflags>-rdynamic
    <toolset>intel,<instruction-set>native:<linkflags>"-xHost"
    $(INTRO_LTO_LINK_PROPERTIES)
    $(INTRO_SSP_LINK_PROPERTIES)
    $(INTRO_MEMORY_CHECKER_LINK_PROPERTIES)
  ;

rule launcher-conditional ( properties * )
{
  local launcher ;

  local runtime-debugging = [ feature.get-values <runtime-debugging> : $(properties) ] ;
  switch "$(runtime-debugging)" {
  case off :
    # Do nothing.
  case "on" :
    local default-libdir = [ get-default-libdir $(properties) ] ;
    local debug-libdir = "$(default-libdir)/debug" ;
    local debug-libdir-native = [ path.native "$(debug-libdir)" ] ;
    launcher += "INTRO_LAUNCHER_PRELOAD=\"$(debug-libdir-native)/libstdc++.so\"" ;
  case * :
    errors.error "an internal error." ;
  }

  local memcheck-run = [ feature.get-values <memcheck-run> : $(properties) ] ;
  switch "$(memcheck-run)" {
  case off :
    # Do nothing.
  case "on" :
    launcher += "INTRO_LAUNCHER_ENABLE_MEMCHECK=1" ;
  case * :
    errors.error "an internal error." ;
  }

  local catchsegv-run = [ feature.get-values <catchsegv-run> : $(properties) ] ;
  switch "$(catchsegv-run)" {
  case off :
    # Do nothing.
  case "on" :
    launcher += "INTRO_LAUNCHER_ENABLE_CATCHSEGV=1" ;
  case * :
    errors.error "an internal error." ;
  }

  local memory-checker = [ feature.get-values <memory-checker> : $(properties) ] ;
  switch "$(memory-checker)" {
  case off :
    # Do nothing.
  case "on" :
    launcher += "INTRO_LAUNCHER_ENABLE_ASAN=1" ;
  case * :
    errors.error "an internal error." ;
  }

  local default-bindir = [ get-default-bindir $(properties) ] ;
  local default-bindir-native = [ path.native "$(default-bindir)" ] ;
  launcher += "\"$(default-bindir-native)/intro-launcher\"" ;

  return <testing.launcher>"$(launcher:J= )" ;
}

constant INTRO_RUN_PROPERTIES
  : <memcheck>on:<memcheck-run>on
    <catchsegv>on:<catchsegv-run>on
    <conditional>@site-config.launcher-conditional
  ;



#############################################################################



{
  local mpi-options ;
  for local path-ver in $(INTRO_GCC_PATHS) $(INTRO_GCC_LATEST_PATHS) $(INTRO_CLANG_PATHS) $(INTRO_CLANG_LATEST_PATHS) {
    local ph ;
    local ver ;
    {
      local tmp = [ regex.split "$(path-ver)" "," ] ;
      ph = "$(tmp[1])" ;
      ver = $(tmp[2]) ;
    }
    #ECHO $(ver) $(ph) ;
    for local address-model in 64 32 {
      local ph2 = "$(ph:D)/../address-model-$(address-model)/bin" ;
      if [ SHELL "[ -x \"$(ph2)/mpic++\" ] && echo -n SUCCESS" ] = SUCCESS {
        local cxxflags = [ SHELL "\"$(ph2)/mpic++\" -showme:compile | tr --delete '\\n'" ] ;
        cxxflags = [ regex.split "$(cxxflags)" " +" ] ;
        local linkflags = [ SHELL "\"$(ph2)/mpic++\" -showme:link | tr --delete '\\n'" ] ;
        linkflags = [ regex.split "$(linkflags)" " +" ] ;
        mpi-options += "<toolset-gcc:version>$(ver),<address-model>$(address-model):<cxxflags>$(cxxflags)" ;
        mpi-options += "<toolset-gcc:version>$(ver),<address-model>$(address-model):<linkflags>$(linkflags)" ;
      }
    }
  }
  for local path-ver in $(INTRO_ICC_PATHS) $(INTRO_ICC_LATEST_PATHS) {
    local ph ;
    local ver ;
    {
      local tmp = [ regex.split "$(path-ver)" "," ] ;
      ph = "$(tmp[1])" ;
      ver = $(tmp[2]) ;
    }
    #ECHO $(ver) $(ph) ;
    for local address-model in 64 32 {
      local arg ;
      switch "$(address-model)" {
      case "64" :
        arg = "intel64" ;
      case "32" :
        arg = "ia32" ;
      case "*" :
        errors.error "an internal error." ;
      }
      local ph2 = "$(ph:D)/../address-model-$(address-model)/bin" ;
      if [ SHELL "[ -x \"$(ph2)/mpic++\" ] && echo -n SUCCESS" ] = SUCCESS {
        local cxxflags = [ SHELL "eval `bash -c '. /opt/intel/bin/compilervars.sh $(arg); echo \"${IDB_HOME:+IDB_HOME=\\\"$IDB_HOME\\\"; export IDB_HOME}\"; echo \"${TBBROOT:+TBBROOT=\\\"$TBBROOT\\\"; export TBBROOT}\"; echo \"${MKLROOT:+MKLROOT=\\\"$MKLROOT\\\"; export MKLROOT}\"; echo \"${IPPROOT:+IPPROOT=\\\"$IPPROOT\\\"; export IPPROOT}\"; echo \"${MIC_LD_LIBRARY_PATH:+MIC_LD_LIBRARY_PATH=\\\"$MIC_LD_LIBRARY_PATH\\\"; export MIC_LD_LIBRARY_PATH}\"; echo \"${INTEL_LICENSE_FILE:+INTEL_LICENSE_FILE=\\\"$INTEL_LICENSE_FILE\\\"; export INTEL_LICENSE_FILE}\"; echo \"${NLSPATH:+NLSPATH=\\\"$NLSPATH\\\"; export NLSPATH}\"; echo \"${MANPATH:+MANPATH=\\\"$MANPATH\\\"; export MANPATH}\"; echo \"${PATH:+PATH=\\\"$PATH\\\"; export PATH}\"; echo \"${LD_LIBRARY_PATH:+LD_LIBRARY_PATH=\\\"$LD_LIBRARY_PATH\\\"; export LD_LIBRARY_PATH}\"; echo \"${DYLD_LIBRARY_PATH:+DYLD_LIBRARY_PATH=\\\"$DYLD_LIBRARY_PATH\\\"; export DYLD_LIBRARY_PATH}\"; echo \"${INCLUDE:+INCLUDE=\\\"$INCLUDE\\\"; export INCLUDE}\"; echo \"${CPATH:+CPATH=\\\"$CPATH\\\"; export CPATH}\"; echo \"${LIBRARY_PATH:+LIBRARY_PATH=\\\"$LIBRARY_PATH\\\"; export LIBRARY_PATH}\"'`; \"$(ph2)/mpic++\" -showme:compile | tr --delete '\\n'" ] ;
        cxxflags = [ regex.split "$(cxxflags)" " +" ] ;
        local linkflags = [ SHELL "eval `bash -c '. /opt/intel/bin/compilervars.sh $(arg); echo \"${IDB_HOME:+IDB_HOME=\\\"$IDB_HOME\\\"; export IDB_HOME}\"; echo \"${TBBROOT:+TBBROOT=\\\"$TBBROOT\\\"; export TBBROOT}\"; echo \"${MKLROOT:+MKLROOT=\\\"$MKLROOT\\\"; export MKLROOT}\"; echo \"${IPPROOT:+IPPROOT=\\\"$IPPROOT\\\"; export IPPROOT}\"; echo \"${MIC_LD_LIBRARY_PATH:+MIC_LD_LIBRARY_PATH=\\\"$MIC_LD_LIBRARY_PATH\\\"; export MIC_LD_LIBRARY_PATH}\"; echo \"${INTEL_LICENSE_FILE:+INTEL_LICENSE_FILE=\\\"$INTEL_LICENSE_FILE\\\"; export INTEL_LICENSE_FILE}\"; echo \"${NLSPATH:+NLSPATH=\\\"$NLSPATH\\\"; export NLSPATH}\"; echo \"${MANPATH:+MANPATH=\\\"$MANPATH\\\"; export MANPATH}\"; echo \"${PATH:+PATH=\\\"$PATH\\\"; export PATH}\"; echo \"${LD_LIBRARY_PATH:+LD_LIBRARY_PATH=\\\"$LD_LIBRARY_PATH\\\"; export LD_LIBRARY_PATH}\"; echo \"${DYLD_LIBRARY_PATH:+DYLD_LIBRARY_PATH=\\\"$DYLD_LIBRARY_PATH\\\"; export DYLD_LIBRARY_PATH}\"; echo \"${INCLUDE:+INCLUDE=\\\"$INCLUDE\\\"; export INCLUDE}\"; echo \"${CPATH:+CPATH=\\\"$CPATH\\\"; export CPATH}\"; echo \"${LIBRARY_PATH:+LIBRARY_PATH=\\\"$LIBRARY_PATH\\\"; export LIBRARY_PATH}\"'`; \"$(ph2)/mpic++\" -showme:link | tr --delete '\\n'" ] ;
        linkflags = [ regex.split "$(linkflags)" " +" ] ;
        mpi-options += "<toolset-intel:version>$(ver),<address-model>$(address-model):<cxxflags>$(cxxflags)" ;
        mpi-options += "<toolset-intel:version>$(ver),<address-model>$(address-model):<linkflags>$(linkflags)" ;
      }
    }
  }
  #ECHO $(mpi-options) ;
  #errors.error "" ;
  if $(mpi-options) {
    using mpi : : $(mpi-options) ;
  }
}


local boost-vers ;

for local boost-prefix in [ path.glob "$(boost-root)" : *.*.* ] {
  local ver = [ regex.match "/([0-9]+\\.[0-9]+\\.[0-9]+)$" : "$(boost-prefix)" : 1 ] ;
  if [ SHELL "[ -f \"$(boost-prefix)/boost/version.hpp\" ] && echo -n SUCCESS" ] != SUCCESS {
    errors.error "an internal error." ;
  }
  if [ SHELL "grep -Fq \"Release $(ver)\" \"$(boost-prefix)/index.html\" && echo -n SUCCESS" ] != SUCCESS {
    errors.error "an internal error." ;
  }
  if ! $(ver) in $(boost-vers) {
    boost-vers += $(ver) ;
  }
}

feature.feature boost-version  : $(boost-vers) : propagated ;
feature.feature boost-layout   : versioned tagged system : propagated ;
feature.feature boost-build-id : : free ;

for local ver in $(boost-vers) {
  alias boost_headers_compile : : <boost-version>$(ver) : : <include>"$(prefix)/boost/$(ver)" ;
}
alias boost_headers_link ;

#ECHO boost-vers: $(boost-vers:J=,) ;
#ECHO "" ;

local rule get-system-bits ( )
{
  local machine = [ SHELL "uname --machine | tr --delete '\\n'" ] ;
  local result ;
  if "$(machine)" = "x86_64" {
    result = "64" ;
  }
  else if "$(machine)" = "x86" {
    result = "32" ;
  }
  else {
    errors.error "an internal error." ;
  }
  return "$(result)" ;
}

rule get-compiler-path ( properties * )
{
  local toolset = [ feature.get-values <toolset> : $(properties) ] ;
  local result ;
  if "$(toolset)" = gcc {
    local ver = [ feature.get-values <toolset-gcc:version> : $(properties) ] ;
    if ! "$(ver)" {
      errors.error "an internal error." ;
    }
    for local i in $(INTRO_GCC_LATEST_PATHS) $(INTRO_GCC_PATHS) {
      local tmp = [ regex.split "$(i)" "," ] ;
      local ph = "$(tmp[1])" ;
      if "$(tmp[2])" = "$(ver)" {
        if "$(result)" {
          errors.error "an internal error." ;
        }
        result = "$(ph)" ;
      }
    }
  }
  else if "$(toolset)" = clang {
    errors.error "TODO: unimplemented." ;
  }
  else if "$(toolset)" = intel {
    errors.error "TODO: unimplemented." ;
  }
  else {
    errors.error "an internal error." ;
  }
  return "$(result)" ;
}

rule get-compiler-prefix ( properties * )
{
  local compiler-path = [ get-compiler-path $(properties) ] ;
  local compiler-prefix = [ path.parent "$(compiler-path)" ] ;
  if ! "$(compiler-prefix)" {
    errors.error "an internal error." ;
  }
  if ! [ path.exists "$(compiler-prefix)" ] {
    errors.error "an internal error." ;
  }
  compiler-prefix = [ path.parent "$(compiler-prefix)" ] ;
  if ! "$(compiler-prefix)" {
    errors.error "an internal error." ;
  }
  if ! [ path.exists "$(compiler-prefix)" ] {
    errors.error "an internal error." ;
  }
  return "$(compiler-prefix)" ;
}

rule get-default-bindir ( properties * )
{
  local compiler-path = [ get-compiler-path $(properties) ] ;
  local result = [ path.parent "$(compiler-path)" ] ;
  if ! "$(result)" {
    errors.error "an internal error." ;
  }
  if ! [ path.exists "$(result)" ] {
    errors.error "an internal error." ;
  }
  return "$(result)" ;
}

rule get-default-libdir ( properties * )
{
  local address-model = [ feature.get-values <address-model> : $(properties) ] ;
  local normalized-address-model ;
  if "$(address-model)" {
    normalized-address-model = "$(address-model)" ;
  }
  else {
    local system-bits = [ get-system-bits ] ;
    switch "$(system-bits)" {
    case 64 :
      normalized-address-model = 64 ;
    case 32 :
      normalized-address-model = 32 ;
    case * :
      errors.error "an internal error." ;
    }
  }

  local result ;
  switch "$(normalized-address-model)" {
  case 64 :
    result = lib64 ;
  case 32 :
    result = lib32 ;
  case * :
    errors.error "an internal error." ;
  }

  local compiler-prefix = [ get-compiler-prefix $(properties) ] ;
  result = "$(compiler-prefix)/$(result)" ;
  if ! "$(result)" {
    errors.error "an internal error." ;
  }
  if ! [ path.exists "$(result)" ] {
    errors.error "an internal error." ;
  }
  return "$(result)" ;
}

local rule is-lib-configurable ( lib : properties * )
{
  local link = [ feature.get-values <link> : $(properties) ] ;
  if ! "$(link)" in shared static {
    errors.error "an internal error." ;
  }
  local lib-link = [ feature.get-values "<$(lib)-link>" : $(properties) ] ;
  if ! "$(lib-link)" {
    lib-link = "$(link)" ;
  }
  if ! "$(lib-link)" in shared static {
    errors.error "an internal error." ;
  }
  local result ;
  if "$(lib-link)" = static {
    result = true ;
  }
  return "$(result)" ;
}

local rule get-lib-variant ( lib : properties * )
{
  local variant = [ feature.get-values <variant> : $(properties) ] ;
  local lib-variant = [ feature.get-values "<$(lib)-variant>" : $(properties) ] ;
  if ! "$(lib-variant)" {
    lib-variant = "$(variant)" ;
  }
  if ! "$(lib-variant)" in [ feature.values <variant> ] {
    errors.error "an internal error." ;
  }
  if ! [ is-lib-configurable "$(lib)" : $(properties) ] && "$(lib-variant)" != "$(variant)" {
    errors.error "`<$(lib)-variant>$(lib-variant)' is specified but not configurable." ;
  }
  return "$(lib-variant)" ;
}

local rule get-lib-link ( lib : dep-libs * : properties * )
{
  local link = [ feature.get-values <link> : $(properties) ] ;
  if ! "$(link)" in shared static {
    errors.error "an internal error." ;
  }
  local lib-link = [ feature.get-values "<$(lib)-link>" : $(properties) ] ;
  if ! "$(lib-link)" {
    lib-link = "$(link)" ;
  }
  if ! "$(lib-link)" in shared static {
    errors.error "an internal error." ;
  }
  if ! [ is-lib-configurable "$(lib)" : $(properties) ] && "$(lib-link)" != "$(link)" {
    errors.error "`<$(lib)-link>$(lib-link)' is specified but not configurable." ;
  }
  if "$(link)" = shared && "$(lib-link)" = static {
    errors.error "`<link>shared' and `<$(lib)-link>static' are not compatible." ;
  }
  for local dep-lib in $(dep-libs) {
    local dep-lib-link = [ feature.get-values "<$(dep-lib)-link>" : $(properties) ] ;
    if ! "$(dep-lib-link)" {
      dep-lib-link = "$(link)" ;
    }
    if ! "$(dep-lib-link)" in shared static {
      errors.error "an internal error." ;
    }
    if "$(dep-lib-link)" = static && "$(lib-link)" = shared {
      errors.error "`<$(dep-lib)-link>static' and `<$(lib)-link>shared' are not compatible." ;
    }
  }
  local runtime-link = [ feature.get-values <runtime-link> : $(properties) ] ;
  if ! "$(runtime-link)" in shared static {
    errors.error "an internal error." ;
  }
  if "$(runtime-link)" = static && "$(lib-link)" = shared {
    errors.error "`<runtime-link>static' and `<$(lib)-link>shared' are not compatible." ;
  }
  return "$(lib-link)" ;
}

local rule get-lib-threading ( lib : dep-libs * : properties * )
{
  local threading = [ feature.get-values <threading> : $(properties) ] ;
  if ! "$(threading)" in single multi {
    errors.error "an internal error." ;
  }
  local lib-threading = [ feature.get-values "<$(lib)-threading>" : $(properties) ] ;
  if ! "$(lib-threading)" {
    lib-threading = "$(threading)" ;
  }
  if ! "$(lib-threading)" in single multi {
    errors.error "an internal error." ;
  }
  if ! [ is-lib-configurable "$(lib)" : $(properties) ] && "$(lib-threading)" != "$(threading)" {
    errors.error "`<$(lib)-threading>$(lib-threading)' is specified but not configurable." ;
  }
  if "$(threading)" = multi && "$(lib-threading)" = single {
    errors.error "`<threading>multi' and `<$(lib)-threading>single' are not compatible." ;
  }
  for local dep-lib in $(dep-libs) {
    local dep-lib-threading = [ feature.get-values "<$(dep-lib)-threading>" : $(properties) ] ;
    if ! "$(dep-lib-threading)" {
      dep-lib-threading = "$(threading)" ;
    }
    if ! "$(dep-lib-threading)" in single multi {
      errors.error "an internal error." ;
    }
    if "$(dep-lib-threading)" = single && "$(lib-threading)" = multi {
      errors.user-error "`<$(dep-lib)-threading>single' and `<$(lib)-threading>multi' are not compatible." ;
    }
  }
  return "$(lib-threading)" ;
}

local rule get-address-model ( properties * )
{
  local address-model = [ feature.get-values <address-model> : $(properties) ] ;
  if ! "$(address-model)" {
    local bits = [ get-system-bits ] ;
    switch "$(bits)" {
    case 64 :
      address-model = 64 ;
    case 32 :
      address-model = 32 ;
    case * :
      errors.error "an internal error." ;
    }
  }
  if ! "$(address-model)" in 64 32 {
    errors.error "an internal error." ;
  }
  return "$(address-model)" ;
}

local rule get-lib-instruction-set ( lib : properties * )
{
  local instruction-set = [ feature.get-values <instruction-set> : $(properties) ] ;
  if ! "$(instruction-set)" {
    instruction-set = generic ;
  }
  if ! "$(instruction-set)" in generic native {
    errors.error "an internal error." ;
  }
  local lib-instruction-set = [ feature.get-values "<$(lib)-instruction-set>" : $(properties) ] ;
  if ! "$(lib-instruction-set)" {
    lib-instruction-set = "$(instruction-set)" ;
  }
  if ! "$(lib-instruction-set)" in generic native {
    errors.error "an internal error." ;
  }
  if ! [ is-lib-configurable "$(lib)" : $(properties) ] && "$(lib-instruction-set)" != "$(instruction-set)" {
    errors.error "`<$(lib)-instruction-set>$(lib-instruction-set)' is specified but not configurable." ;
  }
  return "$(lib-instruction-set)" ;
}

local rule get-lib-lto ( lib : properties * )
{
  local lto = [ feature.get-values <lto> : $(properties) ] ;
  local lib-lto = [ feature.get-values "<$(lib)-lto>" : $(properties) ] ;
  if ! "$(lib-lto)" {
    lib-lto = "$(lto)" ;
  }
  if ! "$(lib-lto)" in off "on" {
    errors.error "an internal error." ;
  }
  if ! [ is-lib-configurable "$(lib)" : $(properties) ] && "$(lib-lto)" != "$(lto)" {
    errors.error "`<$(lib)-lto>$(lib-lto)' is specified but not configurable." ;
  }
  return "$(lib-lto)" ;
}

local rule get-lib-memory-checker ( lib : properties * )
{
  local memory-checker = [ feature.get-values <memory-checker> : $(properties) ] ;
  local lib-memory-checker = [ feature.get-values "<$(lib)-memory-checker>" : $(properties) ] ;
  if ! "$(lib-memory-checker)" {
    lib-memory-checker = "$(memory-checker)" ;
  }
  if ! "$(lib-memory-checker)" in off "on" {
    errors.error "an internal error." ;
  }
  if ! [ is-lib-configurable "$(lib)" : $(properties) ] && "$(lib-memory-checker)" != "$(memory-checker)" {
    errors.error "`<$(lib)-memory-checker>$(lib-memory-checker)' is specified but not configurable." ;
  }
  return "$(lib-memory-checker)" ;
}

local rule get-lib-full-prefix ( lib : dep-libs * : properties * )
{
  local lib-variant = [ get-lib-variant "$(lib)" : $(properties) ] ;
  local lib-link = [ get-lib-link "$(lib)" : "$(dep-libs)" : $(properties) ] ;
  local lib-threading = [ get-lib-threading "$(lib)" : "$(dep-libs)" : $(properties) ] ;
  local address-model = [ get-address-model $(properties) ] ;
  local lib-instruction-set = [ get-lib-instruction-set "$(lib)" : $(properties) ] ;
  local std = [ feature.get-values <std> : $(properties) ] ;
  local lib-lto = [ get-lib-lto "$(lib)" : $(properties) ] ;
  local lib-memory-checker = [ get-lib-memory-checker "$(lib)" : $(properties) ] ;
  local libstdcxx-debug-mode = [ feature.get-values <libstdc++-debug-mode> : $(properties) ] ;

  local ph = [ get-compiler-prefix $(properties) ] ;
  ph = "$(ph)/$(lib-variant)" ;
  ph = "$(ph)/link-$(lib-link)" ;
  ph = "$(ph)/threading-$(lib-threading)" ;
  ph = "$(ph)/address-model-$(address-model)" ;
  ph = "$(ph)/instruction-set-$(lib-instruction-set)" ;
  ph = "$(ph)/$(std)" ;
  ph = "$(ph)/lto-$(lib-lto)" ;
  ph = "$(ph)/memory-checker-$(lib-memory-checker)" ;
  ph = "$(ph)/libstdc++-debug-mode-$(libstdcxx-debug-mode)" ;
  return "$(ph)" ;
}

local rule lib-compile-conditional ( lib : dep-libs * : properties * )
{
  local full-prefix = [ get-lib-full-prefix "$(lib)" : $(dep-libs) : $(properties) ] ;
  return "<include>$(full-prefix)/include" ;
}

local rule lib-lib-conditional ( lib : basename : dep-libs * : properties * )
{
  local ph = [ get-lib-full-prefix "$(lib)" : $(dep-libs) : $(properties) ] ;
  local result ;
  switch [ get-lib-link "$(lib)" : $(dep-libs) : $(properties) ] {
  case shared :
    if ! [ path.exists "$(ph)/lib/lib$(basename).so" ] {
      errors.user-error "`$(ph)/lib/lib$(basename).so' does not exist." ;
    }
    result = "<file>$(ph)/lib/lib$(basename).so" ;
  case static :
    if ! [ path.exists "$(ph)/lib/lib$(basename).a" ] {
      errors.user-error "`$(ph)/lib/lib$(basename).a' does not exist." ;
    }
    result = "<file>$(ph)/lib/lib$(basename).a" ;
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}



lib z.lib : : <name>z ;
lib bz2.lib : : <name>bz2 ;


#############################################################################

feature.feature gmp-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature gmp-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature gmp-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature gmp-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature gmp-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature gmp-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule gmp-compile-conditional ( properties * )
{
  return [ lib-compile-conditional gmp : : $(properties) ] ;
}

alias gmp_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@gmp-compile-conditional
  ;

rule gmp-lib-conditional ( properties * )
{
  return [ lib-lib-conditional gmp : gmp : : $(properties) ] ;
}

lib gmp.lib
  : # No source.
  : <conditional>@gmp-lib-conditional
  ;

alias gmp_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>gmp.lib
  ;


#############################################################################

feature.feature mpfr-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature mpfr-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature mpfr-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature mpfr-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature mpfr-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature mpfr-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule mpfr-compile-conditional ( properties * )
{
  return [ lib-compile-conditional mpfr : gmp : $(properties) ] ;
}

alias mpfr_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@mpfr-compile-conditional
  ;

rule mpfr-lib-conditional ( properties * )
{
  return [ lib-lib-conditional mpfr : mpfr : gmp : $(properties) ] ;
}

lib mpfr.lib
  : gmp.lib
  : <conditional>@mpfr-lib-conditional
  ;

alias mpfr_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>gmp_link
    <library>mpfr.lib
  ;


#############################################################################

feature.feature icudt-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature icudt-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature icudt-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature icudt-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature icudt-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature icudt-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule icudt-compile-conditional ( properties * )
{
  return [ lib-compile-conditional icudt : : $(properties) ] ;
}

alias icudt_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@icudt-compile-conditional
  ;

rule icudt-lib-conditional ( properties * )
{
  return [ lib-lib-conditional icudt : icudata : : $(properties) ] ;
}

lib icudt.lib
  : # No source.
  : <conditional>@icudt-lib-conditional
  ;

alias icudt_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt.lib
  ;


#############################################################################

feature.feature icuuc-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature icuuc-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature icuuc-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature icuuc-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature icuuc-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature icuuc-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule icuuc-compile-conditional ( properties * )
{
  return [ lib-compile-conditional icuuc : icudt : $(properties) ] ;
}

alias icuuc_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@icuuc-compile-conditional
  ;

rule icuuc-lib-conditional ( properties * )
{
  return [ lib-lib-conditional icuuc : icuuc : icudt : $(properties) ] ;
}

lib icuuc.lib
  : icudt.lib
  : <conditional>@icuuc-lib-conditional
  ;

alias icuuc_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc.lib
  ;


#############################################################################

feature.feature icuin-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature icuin-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature icuin-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature icuin-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature icuin-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature icuin-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule icuin-compile-conditional ( properties * )
{
  return [ lib-compile-conditional icuin : icudt icuuc : $(properties) ] ;
}

alias icuin_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@icuin-compile-conditional
  ;

rule icuin-lib-conditional ( properties * )
{
  return [ lib-lib-conditional icuin : icui18n : icudt icuuc : $(properties) ] ;
}

lib icuin.lib
  : icudt.lib
    icuuc.lib
  : <conditional>@icuin-lib-conditional
  ;

alias icuin_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc_link
    <library>icuin.lib
  ;


#############################################################################

feature.feature icuio-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature icuio-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature icuio-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature icuio-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature icuio-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature icuio-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule icuio-compile-conditional ( properties * )
{
  return [ lib-compile-conditional icuio : icudt icuuc icuin : $(properties) ] ;
}

alias icuio_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@icuio-compile-conditional
  ;

rule icuio-lib-conditional ( properties * )
{
  return [ lib-lib-conditional icuio : icuio : icudt icuuc icuin : $(properties) ] ;
}

lib icuio.lib
  : icudt.lib
    icuuc.lib
    icuin.lib
  : <conditional>@icuio-lib-conditional
  ;

alias icuio_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc_link
    <library>icuin_link
    <library>icuio.lib
  ;


#############################################################################

feature.feature icule-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature icule-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature icule-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature icule-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature icule-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature icule-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule icule-compile-conditional ( properties * )
{
  return [ lib-compile-conditional icule : icudt icuuc : $(properties) ] ;
}

alias icule_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@icule-compile-conditional
  ;

rule icule-lib-conditional ( properties * )
{
  return [ lib-lib-conditional icule : icule : icudt icuuc : $(properties) ] ;
}

lib icule.lib
  : icudt.lib
    icuuc.lib
  : <conditional>@icule-lib-conditional
  ;

alias icule_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc_link
    <library>icule.lib
  ;


#############################################################################

feature.feature iculx-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature iculx-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature iculx-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature iculx-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature iculx-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature iculx-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule iculx-compile-conditional ( properties * )
{
  return [ lib-compile-conditional iculx : icudt icuuc icule : $(properties) ] ;
}

alias iculx_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@iculx-compile-conditional
  ;

rule iculx-lib-conditional ( properties * )
{
  return [ lib-lib-conditional iculx : iculx : icudt icuuc icule : $(properties) ] ;
}

lib iculx.lib
  : icudt.lib
    icuuc.lib
    icule.lib
  : <conditional>@iculx-lib-conditional
  ;

alias iculx_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc_link
    <library>icule_link
    <library>iculx.lib
  ;


#############################################################################

feature.feature icutu-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature icutu-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature icutu-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature icutu-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature icutu-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature icutu-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule icutu-compile-conditional ( properties * )
{
  return [ lib-compile-conditional icutu : icudt icuuc icuin : $(properties) ] ;
}

alias icutu_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <conditional>@icutu-compile-conditional
  ;

rule icutu-lib-conditional ( properties * )
{
  return [ lib-lib-conditional icutu : icutu : icudt icuuc icuin : $(properties) ] ;
}

lib icutu.lib
  : icudt.lib
    icuuc.lib
    icuin.lib
  : <conditional>@icutu-lib-conditional
  ;

alias icutu_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc_link
    <library>icuin_link
    <library>icutu.lib
  ;


#############################################################################

feature.feature boost-chrono-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-chrono-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-chrono-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-chrono-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-chrono-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-chrono-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-chrono-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-chrono : boost-system : $(properties) ] {
  case shared :
    result = <define>BOOST_CHRONO_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_chrono_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-chrono-compile-conditional
  ;

rule boost-chrono-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-chrono : boost_chrono : boost-system : $(properties) ] ;
}

lib boost_chrono.lib
  : boost_system.lib
  : <conditional>@boost-chrono-lib-conditional
  ;

alias boost_chrono_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_system_link
    <library>boost_chrono.lib
  ;


#############################################################################

feature.feature boost-date-time-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-date-time-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-date-time-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-date-time-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-date-time-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-date-time-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-date-time-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-date-time : : $(properties) ] {
  case shared :
    result = <define>BOOST_DATE_TIME_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_date_time_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-date-time-compile-conditional
  ;

rule boost-date-time-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-date-time : boost_date_time : : $(properties) ] ;
}

lib boost_date_time.lib
  : # No source.
  : <conditional>@boost-date-time-lib-conditional
  ;

alias boost_date_time_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_date_time.lib
  ;


#############################################################################

feature.feature boost-exception-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
#feature.feature boost-exception-link
#  : [ feature.values <link> ]
#  : propagated optional
#  ;
feature.feature boost-exception-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-exception-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-exception-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-exception-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

alias boost_exception_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
  ;

local rule get-boost-exception-full-prefix ( properties * )
{
  local variant = [ get-lib-variant boost-exception : $(properties) ] ;
  local threading = [ get-lib-threading boost-exception : : $(properties) ] ;
  local address-model = [ get-address-model $(properties) ] ;
  local instruction-set = [ get-lib-instruction-set boost-exception : $(properties) ] ;
  local std = [ feature.get-values <std> : $(properties) ] ;
  local lto = [ get-lib-lto boost-exception : $(properties) ] ;
  local memory-checker = [ get-lib-memory-checker boost-exception : $(properties) ] ;
  local libstdcxx-debug-mode = [ feature.get-values <libstdc++-debug-mode> : $(properties) ] ;

  local ph = [ get-compiler-prefix $(properties) ] ;
  ph = "$(ph)/$(variant)" ;
  ph = "$(ph)/link-static" ;
  ph = "$(ph)/threading-$(threading)" ;
  ph = "$(ph)/address-model-$(address-model)" ;
  ph = "$(ph)/instruction-set-$(instruction-set)" ;
  ph = "$(ph)/$(std)" ;
  ph = "$(ph)/lto-$(lto)" ;
  ph = "$(ph)/memory-checker-$(memory-checker)" ;
  ph = "$(ph)/libstdc++-debug-mode-$(libstdcxx-debug-mode)" ;
  return "$(ph)" ;
}

rule boost-exception-lib-conditional ( properties * )
{
  local full-prefix = [ get-boost-exception-full-prefix $(properties) ] ;
  if ! [ path.exists "$(full-prefix)/lib/libboost_exception.a" ] {
    errors.user-error "`$(full-prefix)/lib/libboost_exception.a' does not exist." ;
  }
  return "<file>$(full-prefix)/lib/libboost_exception.a" ;
}

lib boost_exception.lib
  : # No source.
  : <conditional>@boost-exception-lib-conditional
  ;

alias boost_exception_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_exception.lib
  ;


#############################################################################

feature.feature boost-filesystem-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-filesystem-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-filesystem-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-filesystem-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-filesystem-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-filesystem-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-filesystem-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-filesystem : boost-system : $(properties) ] {
  case shared :
    result = <define>BOOST_FILESYSTEM_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_filesystem_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <define>BOOST_FILESYSTEM_NO_DEPRECATED
    <conditional>@boost-filesystem-compile-conditional
  ;

rule boost-filesystem-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-filesystem : boost_filesystem : boost-system : $(properties) ] ;
}

lib boost_filesystem.lib
  : boost_system.lib
  : <conditional>@boost-filesystem-lib-conditional
  ;

alias boost_filesystem_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_system_link
    <library>boost_filesystem.lib
  ;


#############################################################################

feature.feature boost-graph-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-graph-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-graph-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-graph-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-graph-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-graph-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-graph-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-graph : boost-regex : $(properties) ] {
  case shared :
    result = <define>BOOST_GRAPH_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_graph_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-graph-compile-conditional
  ;

rule boost-graph-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-graph : boost_graph : boost-regex : $(properties) ] ;
}

lib boost_graph.lib
  : boost_regex.lib
  : <conditional>@boost-graph-lib-conditional
  ;

alias boost_graph_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_regex_link
    <library>boost_graph.lib
  ;


#############################################################################

feature.feature boost-graph-parallel-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-graph-parallel-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-graph-parallel-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-graph-parallel-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-graph-parallel-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-graph-parallel-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-graph-parallel-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-graph-parallel : boost-serialization boost-mpi : $(properties) ] {
  case shared :
    result = <define>BOOST_GRAPH_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_graph_parallel_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-graph-parallel-compile-conditional
  ;

rule boost-graph-parallel-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-graph-parallel : boost_graph_parallel : boost-serialization boost-mpi : $(properties) ] ;
}

lib boost_graph_parallel.lib
  : boost_serialization.lib
    boost_mpi.lib
  : <conditional>@boost-graph-parallel-lib-conditional
  ;

alias boost_graph_parallel_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_serialization_link
    <library>boost_mpi_link
    <library>boost_graph_parallel.lib
  ;


#############################################################################

feature.feature boost-iostreams-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-iostreams-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-iostreams-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-iostreams-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-iostreams-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-iostreams-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-iostreams-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-iostreams : : $(properties) ] {
  case shared :
    result = <define>BOOST_IOSTREAMS_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_iostreams_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-iostreams-compile-conditional
  ;

rule boost-iostreams-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-iostreams : boost_iostreams : : $(properties) ] ;
}

lib boost_iostreams.lib
  : z.lib
    bz2.lib
  : <conditional>@boost-iostreams-lib-conditional
  ;

alias boost_iostreams_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_iostreams.lib
  ;


#############################################################################

feature.feature boost-locale-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-locale-link
  : [ feature.values <link> ]
  : propagated optional
  ;
#feature.feature boost-locale-threading
#  : [ feature.values <threading> ]
#  : propagated optional
#  ;
feature.feature boost-locale-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-locale-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-locale-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-locale-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-locale : icudt icuuc icuin boost-thread : $(properties) ] {
  case shared :
    result = <define>BOOST_LOCALE_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_locale_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-locale-compile-conditional
  ;

local rule get-boost-locale-full-prefix ( properties * )
{
  local variant = [ get-lib-variant boost-locale : $(properties) ] ;
  local link = [ get-lib-link boost-locale : icudt icuuc icuin boost-thread : $(properties) ] ;
  local address-model = [ get-address-model $(properties) ] ;
  local instruction-set = [ get-lib-instruction-set boost-locale : $(properties) ] ;
  local std = [ feature.get-values <std> : $(properties) ] ;
  local lto = [ get-lib-lto boost-locale : $(properties) ] ;
  local memory-checker = [ get-lib-memory-checker boost-locale : $(properties) ] ;
  local libstdcxx-debug-mode = [ feature.get-values <libstdc++-debug-mode> : $(properties) ] ;

  local ph = [ get-compiler-prefix $(properties) ] ;
  ph = "$(ph)/$(variant)" ;
  ph = "$(ph)/link-$(link)" ;
  ph = "$(ph)/threading-multi" ;
  ph = "$(ph)/address-model-$(address-model)" ;
  ph = "$(ph)/instruction-set-$(instruction-set)" ;
  ph = "$(ph)/$(std)" ;
  ph = "$(ph)/lto-$(lto)" ;
  ph = "$(ph)/memory-checker-$(memory-checker)" ;
  ph = "$(ph)/libstdc++-debug-mode-$(libstdcxx-debug-mode)" ;
  return "$(ph)" ;
}

rule boost-locale-lib-conditional ( properties * )
{
  local ph = [ get-boost-locale-full-prefix $(properties) ] ;
  local result ;
  switch [ get-lib-link boost-locale : icudt icuuc icuin boost-thread : $(properties) ] {
  case shared :
    if ! [ path.exists "$(ph)/lib/libboost_locale.so" ] {
      errors.user-error "`$(ph)/lib/libboost_locale.so' does not exist." ;
    }
    result = "<file>$(ph)/lib/libboost_locale.so" ;
  case static :
    if ! [ path.exists "$(ph)/lib/libboost_locale.a" ] {
      errors.user-error "`$(ph)/lib/libboost_locale.a' does not exist." ;
    }
    result = "<file>$(ph)/lib/libboost_locale.a" ;
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

lib boost_locale.lib
  : icudt.lib
    icuuc.lib
    icuin.lib
    boost_thread.lib
  : <conditional>@boost-locale-lib-conditional
  ;

alias boost_locale_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc_link
    <library>icuin_link
    <library>boost_thread_link
    <library>boost_locale.lib
  ;


#############################################################################

feature.feature boost-math-c99-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-math-c99-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-math-c99-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-math-c99-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-math-c99-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-math-c99-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-math-c99-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-math-c99 : : $(properties) ] {
  case shared :
    result = <define>BOOST_MATH_TR1_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_math_c99_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-math-c99-compile-conditional
  ;

rule boost-math-c99-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-math-c99 : boost_math_c99 : : $(properties) ] ;
}

lib boost_math_c99.lib
  : # No source.
  : <conditional>@boost-math-c99-lib-conditional
  ;

alias boost_math_c99_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_math_c99.lib
  ;


#############################################################################

feature.feature boost-math-c99f-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-math-c99f-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-math-c99f-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-math-c99f-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-math-c99f-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-math-c99f-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-math-c99f-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-math-c99f : : $(properties) ] {
  case shared :
    result = <define>BOOST_MATH_TR1_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_math_c99f_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-math-c99f-compile-conditional
  ;

rule boost-math-c99f-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-math-c99f : boost_math_c99f : : $(properties) ] ;
}

lib boost_math_c99f.lib
  : # No source.
  : <conditional>@boost-math-c99f-lib-conditional
  ;

alias boost_math_c99f_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_math_c99f.lib
  ;


#############################################################################

feature.feature boost-math-c99l-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-math-c99l-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-math-c99l-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-math-c99l-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-math-c99l-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-math-c99l-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-math-c99l-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-math-c99l : : $(properties) ] {
  case shared :
    result = <define>BOOST_MATH_TR1_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_math_c99l_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-math-c99l-compile-conditional
  ;

rule boost-math-c99l-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-math-c99l : boost_math_c99l : : $(properties) ] ;
}

lib boost_math_c99l.lib
  : # No source.
  : <conditional>@boost-math-c99l-lib-conditional
  ;

alias boost_math_c99l_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_math_c99l.lib
  ;


#############################################################################

feature.feature boost-math-tr1-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-math-tr1-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-math-tr1-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-math-tr1-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-math-tr1-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-math-tr1-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-math-tr1-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-math-tr1 : : $(properties) ] {
  case shared :
    result = <define>BOOST_MATH_TR1_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_math_tr1_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-math-tr1-compile-conditional
  ;

rule boost-math-tr1-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-math-tr1 : boost_math_tr1 : : $(properties) ] ;
}

lib boost_math_tr1.lib
  : # No source.
  : <conditional>@boost-math-tr1-lib-conditional
  ;

alias boost_math_tr1_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_math_tr1.lib
  ;


#############################################################################

feature.feature boost-math-tr1f-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-math-tr1f-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-math-tr1f-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-math-tr1f-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-math-tr1f-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-math-tr1f-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-math-tr1f-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-math-tr1f : : $(properties) ] {
  case shared :
    result = <define>BOOST_MATH_TR1_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_math_tr1f_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-math-tr1f-compile-conditional
  ;

rule boost-math-tr1f-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-math-tr1f : boost_math_tr1f : : $(properties) ] ;
}

lib boost_math_tr1f.lib
  : # No source.
  : <conditional>@boost-math-tr1f-lib-conditional
  ;

alias boost_math_tr1f_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_math_tr1f.lib
  ;


#############################################################################

feature.feature boost-math-tr1l-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-math-tr1l-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-math-tr1l-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-math-tr1l-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-math-tr1l-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-math-tr1l-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-math-tr1l-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-math-tr1l : : $(properties) ] {
  case shared :
    result = <define>BOOST_MATH_TR1_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_math_tr1l_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-math-tr1l-compile-conditional
  ;

rule boost-math-tr1l-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-math-tr1l : boost_math_tr1l : : $(properties) ] ;
}

lib boost_math_tr1l.lib
  : # No source.
  : <conditional>@boost-math-tr1l-lib-conditional
  ;

alias boost_math_tr1l_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_math_tr1l.lib
  ;


#############################################################################

feature.feature boost-mpi-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-mpi-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-mpi-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-mpi-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-mpi-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-mpi-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-mpi-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-mpi : boost-serialization : $(properties) ] {
  case shared :
    result = <define>BOOST_MPI_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_mpi_compile
  : /mpi//mpi
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-mpi-compile-conditional
  ;

rule boost-mpi-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-mpi : boost_mpi : boost-serialization : $(properties) ] ;
}

lib boost_mpi.lib
  : boost_serialization.lib
  : <conditional>@boost-mpi-lib-conditional
  ;

alias boost_mpi_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>/mpi//mpi
    <library>boost_serialization_link
    <library>boost_mpi.lib
  ;


#############################################################################

feature.feature boost-prg-exec-monitor-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-prg-exec-monitor-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-prg-exec-monitor-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-prg-exec-monitor-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-prg-exec-monitor-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-prg-exec-monitor-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-prg-exec-monitor-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-prg-exec-monitor : : $(properties) ] {
  case shared :
    result = <define>BOOST_TEST_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_prg_exec_monitor_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-prg-exec-monitor-compile-conditional
  ;

rule boost-prg-exec-monitor-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-prg-exec-monitor : boost_prg_exec_monitor : : $(properties) ] ;
}

lib boost_prg_exec_monitor.lib
  : # No source.
  : <conditional>@boost-prg-exec-monitor-lib-conditional
  ;

alias boost_prg_exec_monitor_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_prg_exec_monitor.lib
  ;


#############################################################################

feature.feature boost-program-options-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-program-options-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-program-options-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-program-options-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-program-options-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-program-options-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-program-options-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-program-options : : $(properties) ] {
  case shared :
    result = <define>BOOST_PROGRAM_OPTIONS_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_program_options_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-program-options-compile-conditional
  ;

rule boost-program-options-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-program-options : boost_program_options : : $(properties) ] ;
}

lib boost_program_options.lib
  : # No source.
  : <conditional>@boost-program-options-lib-conditional
  ;

alias boost_program_options_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_program_options.lib
  ;


#############################################################################

feature.feature boost-python-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-python-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-python-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-python-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-python-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-python-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-python-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-python : : $(properties) ] {
  case shared :
    result = <define>BOOST_PYTHON_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_python_compile
  : /python//python
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-python-compile-conditional
  ;

rule boost-python-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-python : boost_python : : $(properties) ] ;
}

lib boost_python.lib
  : /python//python
  : <conditional>@boost-python-lib-conditional
  ;

alias boost_python_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_python.lib
  ;


#############################################################################

feature.feature boost-random-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-random-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-random-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-random-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-random-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-random-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-random-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-random : : $(properties) ] {
  case shared :
    result = <define>BOOST_RANDOM_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_random_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-random-compile-conditional
  ;

rule boost-random-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-random : boost_random : : $(properties) ] ;
}

lib boost_random.lib
  : # No source.
  : <conditional>@boost-random-lib-conditional
  ;

alias boost_random_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_random.lib
  ;


#############################################################################

feature.feature boost-regex-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-regex-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-regex-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-regex-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-regex-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-regex-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-regex-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-regex : icudt icuuc icuin : $(properties) ] {
  case shared :
    result = <define>BOOST_REGEX_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_regex_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-regex-compile-conditional
  ;

rule boost-regex-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-regex : boost_regex : icudt icuuc icuin : $(properties) ] ;
}

lib boost_regex.lib
  : icudt.lib
    icuuc.lib
    icuin.lib
  : <conditional>@boost-regex-lib-conditional
  ;

alias boost_regex_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>icudt_link
    <library>icuuc_link
    <library>icuin_link
    <library>boost_regex.lib
  ;


#############################################################################

feature.feature boost-serialization-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-serialization-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-serialization-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-serialization-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-serialization-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-serialization-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-serialization-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-serialization : : $(properties) ] {
  case shared :
    result = <define>BOOST_SERIALIZATION_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_serialization_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-serialization-compile-conditional
  ;

rule boost-serialization-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-serialization : boost_serialization : : $(properties) ] ;
}

lib boost_serialization.lib
  : # No source.
  : <conditional>@boost-serialization-lib-conditional
  ;

alias boost_serialization_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_serialization.lib
  ;


#############################################################################

feature.feature boost-signals-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-signals-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-signals-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-signals-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-signals-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-signals-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-signals-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-signals : : $(properties) ] {
  case shared :
    result = <define>BOOST_SIGNALS_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_signals_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-signals-compile-conditional
  ;

rule boost-signals-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-signals : boost_signals : : $(properties) ] ;
}

lib boost_signals.lib
  : # No source.
  : <conditional>@boost-signals-lib-conditional
  ;

alias boost_signals_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_signals.lib
  ;


#############################################################################

feature.feature boost-system-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-system-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-system-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-system-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-system-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-system-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-system-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-system : : $(properties) ] {
  case shared :
    result = <define>BOOST_SYSTEM_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_system_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <define>BOOST_SYSTEM_NO_DEPRECATED
    <conditional>@boost-system-compile-conditional
  ;

rule boost-system-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-system : boost_system : : $(properties) ] ;
}

lib boost_system.lib
  : # No source.
  : <conditional>@boost-system-lib-conditional
  ;

alias boost_system_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_system.lib
  ;


#############################################################################

feature.feature boost-test-exec-monitor-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
#feature.feature boost-test-exec-monitor-link
#  : [ feature.values <link> ]
#  : propagated optional
#  ;
feature.feature boost-test-exec-monitor-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-test-exec-monitor-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-test-exec-monitor-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-test-exec-monitor-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

alias boost_test_exec_monitor_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
  ;

local rule get-boost-test-exec-monitor-full-prefix ( properties * )
{
  local variant = [ get-lib-variant boost-test-exec-monitor : $(properties) ] ;
  local threading = [ get-lib-threading boost-test-exec-monitor : : $(properties) ] ;
  local address-model = [ get-address-model $(properties) ] ;
  local instruction-set = [ get-lib-instruction-set boost-test-exec-monitor : $(properties) ] ;
  local std = [ feature.get-values <std> : $(properties) ] ;
  local lto = [ get-lib-lto boost-test-exec-monitor : $(properties) ] ;
  local memory-checker = [ get-lib-memory-checker boost-test-exec-monitor : $(properties) ] ;
  local libstdcxx-debug-mode = [ feature.get-values <libstdc++-debug-mode> : $(properties) ] ;

  local ph = [ get-compiler-prefix $(properties) ] ;
  ph = "$(ph)/$(variant)" ;
  ph = "$(ph)/link-static" ;
  ph = "$(ph)/threading-$(threading)" ;
  ph = "$(ph)/address-model-$(address-model)" ;
  ph = "$(ph)/instruction-set-$(instruction-set)" ;
  ph = "$(ph)/$(std)" ;
  ph = "$(ph)/lto-$(lto)" ;
  ph = "$(ph)/memory-checker-$(memory-checker)" ;
  ph = "$(ph)/libstdc++-debug-mode-$(libstdcxx-debug-mode)" ;
  return "$(ph)" ;
}

rule boost-test-exec-monitor-lib-conditional ( properties * )
{
  local full-prefix = [ get-boost-test-exec-monitor-full-prefix $(properties) ] ;
  if ! [ path.exists "$(full-prefix)/lib/libboost_test_exec_monitor.a" ] {
    errors.user-error "`$(full-prefix)/lib/libboost_test_exec_monitor.a' does not exist." ;
  }
  return "<file>$(full-prefix)/lib/libboost_test_exec_monitor.a" ;
}

lib boost_test_exec_monitor.lib
  : # No source.
  : <conditional>@boost-test-exec-monitor-lib-conditional
  ;

alias boost_test_exec_monitor_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_test_exec_monitor.lib
  ;


#############################################################################

feature.feature boost-thread-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-thread-link
  : [ feature.values <link> ]
  : propagated optional
  ;
#feature.feature boost-thread-threading
#  : [ feature.values <threading> ]
#  : propagated optional
#  ;
feature.feature boost-thread-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-thread-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-thread-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-thread-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-thread : boost-system boost-chrono : $(properties) ] {
  case shared :
    result = <define>BOOST_THREAD_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_thread_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-thread-compile-conditional
  ;

local rule get-boost-thread-full-prefix ( properties * )
{
  local variant = [ get-lib-variant boost-thread : $(properties) ] ;
  local link = [ get-lib-link boost-thread : boost-system boost-chrono : $(properties) ] ;
  local address-model = [ get-address-model $(properties) ] ;
  local instruction-set = [ get-lib-instruction-set boost-thread : $(properties) ] ;
  local std = [ feature.get-values <std> : $(properties) ] ;
  local lto = [ get-lib-lto boost-thread : $(properties) ] ;
  local memory-checker = [ get-lib-memory-checker boost-thread : $(properties) ] ;
  local libstdcxx-debug-mode = [ feature.get-values <libstdc++-debug-mode> : $(properties) ] ;

  local ph = [ get-compiler-prefix $(properties) ] ;
  ph = "$(ph)/$(variant)" ;
  ph = "$(ph)/link-$(link)" ;
  ph = "$(ph)/threading-multi" ;
  ph = "$(ph)/address-model-$(address-model)" ;
  ph = "$(ph)/instruction-set-$(instruction-set)" ;
  ph = "$(ph)/$(std)" ;
  ph = "$(ph)/lto-$(lto)" ;
  ph = "$(ph)/memory-checker-$(memory-checker)" ;
  ph = "$(ph)/libstdc++-debug-mode-$(libstdcxx-debug-mode)" ;
  return "$(ph)" ;
}

rule boost-thread-lib-conditional ( properties * )
{
  local ph = [ get-boost-thread-full-prefix $(properties) ] ;
  local result ;
  switch [ get-lib-link boost-thread : boost-system boost-chrono : $(properties) ] {
  case shared :
    if ! [ path.exists "$(ph)/lib/libboost_thread.so" ] {
      errors.user-error "`$(ph)/lib/libboost_thread.so' does not exist." ;
    }
    result = "<file>$(ph)/lib/libboost_thread.so" ;
  case static :
    if ! [ path.exists "$(ph)/lib/libboost_thread.a" ] {
      errors.user-error "`$(ph)/lib/libboost_thread.a' does not exist." ;
    }
    result = "<file>$(ph)/lib/libboost_thread.a" ;
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

lib boost_thread.lib
  : boost_system.lib
    boost_chrono.lib
  : <conditional>@boost-thread-lib-conditional
  ;

alias boost_thread_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_system_link
    <library>boost_chrono_link
    <library>boost_thread.lib
  ;


#############################################################################

feature.feature boost-timer-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-timer-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-timer-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-timer-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-timer-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-timer-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-timer-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-timer : boost-system boost-chrono : $(properties) ] {
  case shared :
    result = <define>BOOST_TIMER_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_timer_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-timer-compile-conditional
  ;

rule boost-timer-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-timer : boost_timer : boost-system boost-chrono : $(properties) ] ;
}

lib boost_timer.lib
  : boost_system.lib
    boost_chrono.lib
  : <conditional>@boost-timer-lib-conditional
  ;

alias boost_timer_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_system_link
    <library>boost_chrono_link
    <library>boost_timer.lib
  ;


#############################################################################

feature.feature boost-unit-test-framework-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-unit-test-framework-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-unit-test-framework-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-unit-test-framework-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-unit-test-framework-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-unit-test-framework-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-unit-test-framework-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-unit-test-framework : : $(properties) ] {
  case shared :
    result = <define>BOOST_TEST_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_unit_test_framework_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-unit-test-framework-compile-conditional
  ;

rule boost-unit-test-framework-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-unit-test-framework : boost_unit_test_framework : : $(properties) ] ;
}

lib boost_unit_test_framework.lib
  : # No source.
  : <conditional>@boost-unit-test-framework-lib-conditional
  ;

alias boost_unit_test_framework_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_unit_test_framework.lib
  ;


#############################################################################

feature.feature boost-wave-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-wave-link
  : [ feature.values <link> ]
  : propagated optional
  ;
#feature.feature boost-wave-threading
#  : [ feature.values <threading> ]
#  : propagated optional
#  ;
feature.feature boost-wave-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-wave-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-wave-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-wave-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-wave : boost-system boost-chrono boost-date-time boost-filesystem boost-thread : $(properties) ] {
  case shared :
    result = <define>BOOST_WAVE_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_wave_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-wave-compile-conditional
  ;

local rule get-boost-wave-full-prefix ( properties * )
{
  local variant = [ get-lib-variant boost-wave : $(properties) ] ;
  local link = [ get-lib-link boost-wave : boost-system boost-chrono boost-date-time boost-filesystem boost-thread : $(properties) ] ;
  local address-model = [ get-address-model $(properties) ] ;
  local instruction-set = [ get-lib-instruction-set boost-wave : $(properties) ] ;
  local std = [ feature.get-values <std> : $(properties) ] ;
  local lto = [ get-lib-lto boost-wave : $(properties) ] ;
  local memory-checker = [ get-lib-memory-checker boost-wave : $(properties) ] ;
  local libstdcxx-debug-mode = [ feature.get-values <libstdc++-debug-mode> : $(properties) ] ;

  local ph = [ get-compiler-prefix $(properties) ] ;
  ph = "$(ph)/$(variant)" ;
  ph = "$(ph)/link-$(link)" ;
  ph = "$(ph)/threading-multi" ;
  ph = "$(ph)/address-model-$(address-model)" ;
  ph = "$(ph)/instruction-set-$(instruction-set)" ;
  ph = "$(ph)/$(std)" ;
  ph = "$(ph)/lto-$(lto)" ;
  ph = "$(ph)/memory-checker-$(memory-checker)" ;
  ph = "$(ph)/libstdc++-debug-mode-$(libstdcxx-debug-mode)" ;
  return "$(ph)" ;
}

rule boost-wave-lib-conditional ( properties * )
{
  local ph = [ get-boost-wave-full-prefix $(properties) ] ;
  local result ;
  switch [ get-lib-link boost-wave : boost-system boost-chrono boost-date-time boost-filesystem boost-thread : $(properties) ] {
  case shared :
    if ! [ path.exists "$(ph)/lib/libboost_wave.so" ] {
      errors.user-error "`$(ph)/lib/libboost_wave.so' does not exist." ;
    }
    result = "<file>$(ph)/lib/libboost_wave.so" ;
  case static :
    if ! [ path.exists "$(ph)/lib/libboost_wave.a" ] {
      errors.user-error "`$(ph)/lib/libboost_wave.a' does not exist." ;
    }
    result = "<file>$(ph)/lib/libboost_wave.a" ;
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

lib boost_wave.lib
  : boost_system.lib
    boost_chrono.lib
    boost_date_time.lib
    boost_filesystem.lib
    boost_thread.lib
  : <conditional>@boost-wave-lib-conditional
  ;

alias boost_wave_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_system_link
    <library>boost_chrono_link
    <library>boost_date_time_link
    <library>boost_filesystem_link
    <library>boost_thread_link
    <library>boost_wave.lib
  ;


#############################################################################

feature.feature boost-wserialization-variant
  : [ feature.values <variant> ]
  : propagated optional
  ;
feature.feature boost-wserialization-link
  : [ feature.values <link> ]
  : propagated optional
  ;
feature.feature boost-wserialization-threading
  : [ feature.values <threading> ]
  : propagated optional
  ;
feature.feature boost-wserialization-instruction-set
  : generic native
  : propagated optional
  ;
feature.feature boost-wserialization-lto
  : [ feature.values <lto> ]
  : propagated optional
  ;
feature.feature boost-wserialization-memory-checker
  : [ feature.values <memory-checker> ]
  : propagated optional
  ;

rule boost-wserialization-compile-conditional ( properties * )
{
  local result ;
  switch [ get-lib-link boost-wserialization : boost-serialization : $(properties) ] {
  case shared :
    result = <define>BOOST_SERIALIZATION_DYN_LINK ;
  case static :
    # Do nothing.
  case * :
    errors.error "an internal error." ;
  }
  return $(result) ;
}

alias boost_wserialization_compile
  : # No source.
  : # No requirement.
  : # No default-build.
  : <define>BOOST_ALL_NO_LIB
    <conditional>@boost-wserialization-compile-conditional
  ;

rule boost-wserialization-lib-conditional ( properties * )
{
  return [ lib-lib-conditional boost-wserialization : boost_wserialization : boost-serialization : $(properties) ] ;
}

lib boost_wserialization.lib
  : boost_serialization.lib
  : <conditional>@boost-wserialization-lib-conditional
  ;

alias boost_wserialization_link
  : # No source.
  : # No requirement.
  : # No default-build.
  : <library>boost_serialization_link
    <library>boost_wserialization.lib
  ;



#############################################################################

#BOOST_ARCHIVE_DYN_LINK
#BOOST_ASIO_DYN_LINK
#BOOST_EX_CHRONO_DYN_LINK
#BOOST_IOSTREAMS_DETAIL_CONFIG_DYN_LINK
#BOOST_MPI_PYTHON_DYN_LINK
