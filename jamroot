import errors ;
import feature : feature ;
import modules ;
import path ;
import regex ;

path-constant INTRO_ROOT_DIR : . ;


local prefix = ;
local stdout = ;
local stderr = ;
for local argv in [ modules.peek : ARGV ] {
  local tmp = ;
  tmp = [ regex.match "^--prefix=(/.*)$" : $(argv) : 1 ] ;
  if $(tmp) {
    if $(prefix) {
      errors.error ;
    }
    else {
      prefix = $(tmp) ;
    }
  }
  tmp = [ regex.match "^--stdout=(/.*)$" : $(argv) : 1 ] ;
  if $(tmp) {
    if $(stdout) {
      errors.error ;
    }
    else {
      stdout = $(tmp) ;
    }
  }
  tmp = [ regex.match "^--stderr=(/.*)$" : $(argv) : 1 ] ;
  if $(tmp) {
    if $(stderr) {
      errors.error ;
    }
    else {
      stderr = $(tmp) ;
    }
  }
}


project intro
  : default-build
    <intro-prefix>$(prefix)
    <intro-stdout>$(stdout)
    <intro-stderr>$(stderr)
  : build-dir bin
  ;


feature intro-build : unspecified x86_64-w64-mingw32 i686-w64-mingw32 : propagated incidental ;
for local i in [ path.glob $(INTRO_ROOT_DIR) : */config.guess ] {
  local b = [ SHELL "\"$(i)\" | tr --delete '\n'" ] ;
  if ! $(b) in [ feature.values <intro-build> ] {
    feature.extend intro-build : $(b) ;
  }
}

feature intro-host : [ feature.values <intro-build> ] : propagated ;

feature intro-target : [ feature.values <intro-host> ] : propagated ;

feature intro-abi : unspecified 32 64 o32 n32 aix64 mode64 mode32 : propagated ;

feature intro-prefix : /usr/local : propagated incidental ;
if $(prefix) && ! $(prefix) in [ feature.values <intro-prefix> ] {
  feature.extend intro-prefix : $(prefix) ;
}
for local i in [ feature.values <intro-prefix> ] {
  for local j in [ feature.values <intro-host> ] {
    if $(j) != unspecified && ! $(i)/$(j) in [ feature.values <intro-prefix> ] {
      feature.extend intro-prefix : $(i)/$(j) ;
    }
  }
}

feature intro-link : unspecified both shared static : propagated ;

feature intro-check : unspecified yes no : propagated incidental ;
feature intro-check-hidden : [ feature.values <intro-check> ] : propagated incidental ;

feature intro-stdout : : path propagated incidental optional ;
if $(stdout) {
  feature.extend intro-stdout : $(stdout) ;
}

feature intro-stderr : : path propagated incidental optional ;
if $(stderr) {
  feature.extend intro-stderr : $(stderr) ;
}


feature gmp-version : unspecified : propagated ;
ECHO patience... ;
local gmp-versions = [ regex.split [ SHELL "\"$(INTRO_ROOT_DIR)/gmp-versions.sh\" || /bin/echo -n 'error'" ] " +" ] ;
for local i in $(gmp-versions) {
  if [ regex.match "^([0123456789]+(\\.[0123456789]+(\\.[0123456789]+)?)?)$" : $(i) : 1 ] {
    feature.extend gmp-version : $(i) ;
  }
  else {
    errors.error "ERROR: failed to extract GMP versions." ;
  }
}

feature gmp-version-hidden : [ feature.values <gmp-version> ] : propagated incidental ;


feature mpfr-version : unspecified : propagated ;
ECHO patience... ;
local mpfr-versions = [ regex.split [ SHELL "\"$(INTRO_ROOT_DIR)/mpfr-versions.sh\" || /bin/echo -n 'error'" ] " +" ] ;
for local i in $(mpfr-versions) {
  if [ regex.match "^([0123456789]+(\\.[0123456789]+(\\.[0123456789]+)?)?)$" : $(i) : 1 ] {
    feature.extend mpfr-version : $(i) ;
  }
  else {
    errors.error "ERROR: failed to extract MPFR versions." ;
  }
}

feature mpfr-version-hidden : [ feature.values <mpfr-version> ] : propagated incidental ;


feature mpc-version : unspecified : propagated ;
ECHO patience... ;
local mpc-versions = [ regex.split [ SHELL "\"$(INTRO_ROOT_DIR)/mpc-versions.sh\" || /bin/echo -n 'error'" ] " +" ] ;
for local i in $(mpc-versions) {
  if [ regex.match "^([0123456789]+(\\.[0123456789]+(\\.[0123456789]+)?)?)$" : $(i) : 1 ] {
    feature.extend mpc-version : $(i) ;
  }
  else {
    errors.error "ERROR: failed to extract MPC versions." ;
  }
}

feature mpc-version-hidden : [ feature.values <mpc-version> ] : propagated incidental ;


feature binutils-version : unspecified : propagated ;
ECHO patience... ;
local binutils-versions = [ regex.split [ SHELL "\"$(INTRO_ROOT_DIR)/binutils-versions.sh\" || /bin/echo -n 'error'" ] " +" ] ;
for local i in $(binutils-versions) {
  if [ regex.match "^([0123456789]+\\.[0123456789]+(\\.[0123456789]+)?)$" : $(i) : 1 ] {
    feature.extend binutils-version : $(i) ;
  }
  else {
    errors.error "ERROR: failed to extract Binutils versions." ;
  }
}

feature binutils-version-hidden : [ feature.values <binutils-version> ] : propagated incidental ;


feature gcc-version : unspecified : propagated ;
ECHO patience... ;
for local i in [ regex.split [ SHELL "\"$(INTRO_ROOT_DIR)/gcc-versions.sh\" || /bin/echo -n 'error'" ] " +" ] {
  if [ regex.match "^([0123456789]+(\\.[0123456789]+(\\.[0123456789]+)?)?)$" : $(i) : 1 ] {
    feature.extend gcc-version : $(i) ;
  }
  else {
    errors.error "ERROR: failed to extract GCC versions." ;
  }
}

feature gcc-default : no yes : propagated incidental ;
