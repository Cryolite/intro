import errors ;
import feature : feature ;
import modules ;
import option ;
import regex ;

path-constant INTRO_ROOT_DIR : . ;

import "$(INTRO_ROOT_DIR)/compilers"
  : is-valid
    is-gcc
    is-clang
    is-icc
    get-clang-latest-version
    get-backend-gcc
    get-frontend-version
    split-frontend-and-backend
    get-default-bits
  ;
"$(INTRO_ROOT_DIR)/compilers.init" "$(INTRO_ROOT_DIR)" ;


local .binutils-latest ;
local .lcov-latest ;
local .gcovr-latest ;
local .gmp-latest ;
local .mpfr-latest ;
local .mpc-latest ;
local .ppl-latest ;
local .isl-latest ;
local .cloog-latest ;
local .icu4c-latest ;
local .openmpi-latest ;
local .boost-latest ;
local .valgrind-latest ;

local rule get-boost-latest-version ( )
{
  if ! "$(.boost-latest)" {
    .boost-latest = [ SHELL "'$(INTRO_ROOT_DIR)/boost/latest.sh' || echo -n error" ] ;
    if "$(.boost-latest)" = "error" {
      errors.error "failed to extract Boost latest version." ;
    }
  }
  return "$(.boost-latest)" ;
}

local rule get-binutils-latest-version ( )
{
  if ! "$(.binutils-latest)" {
    .binutils-latest = [ SHELL "'$(INTRO_ROOT_DIR)/binutils/latest.sh' || echo -n error" ] ;
    if "$(.binutils-latest)" = "error" {
      errors.error "failed to extract binutils latest version." ;
    }
  }
  return "$(.binutils-latest)" ;
}

local rule get-lcov-latest-version ( )
{
  if ! "$(.lcov-latest)" {
    .lcov-latest = [ SHELL "'$(INTRO_ROOT_DIR)/lcov/latest.sh' || echo -n error" ] ;
    if "$(.lcov-latest)" = error {
      errors.error "failed to extract LCOV latest version." ;
    }
  }
  return "$(.lcov-latest)" ;
}

local rule get-gcovr-latest-version ( )
{
  if ! "$(.gcovr-latest)" {
    .gcovr-latest = [ SHELL "'$(INTRO_ROOT_DIR)/gcovr/latest.sh' || echo -n error" ] ;
    if "$(.gcovr-latest)" = error {
      errors.error "failed to extract gcovr latest version." ;
    }
  }
  return "$(.gcovr-latest)" ;
}

local rule get-gmp-latest-version ( )
{
  if ! "$(.gmp-latest)" {
    .gmp-latest = [ SHELL "'$(INTRO_ROOT_DIR)/gmp/latest.sh' || echo -n error" ] ;
    if "$(.gmp-latest)" = "error" {
      errors.error "failed to extract GMP latest version." ;
    }
  }
  return "$(.gmp-latest)" ;
}

local rule get-mpfr-latest-version ( )
{
  if ! "$(.mpfr-latest)" {
    .mpfr-latest = [ SHELL "'$(INTRO_ROOT_DIR)/mpfr/latest.sh' || echo -n error" ] ;
    if "$(.mpfr-latest)" = "error" {
      errors.error "failed to extract MPFR latest version." ;
    }
  }
  return "$(.mpfr-latest)" ;
}

local rule get-mpc-latest-version ( )
{
  if ! "$(.mpc-latest)" {
    .mpc-latest = [ SHELL "'$(INTRO_ROOT_DIR)/mpc/latest.sh' || echo -n error" ] ;
    if "$(.mpc-latest)" = "error" {
      errors.error "failed to extract MPC latest version." ;
    }
  }
  return "$(.mpc-latest)" ;
}

local rule get-ppl-latest-version ( )
{
  if ! "$(.ppl-latest)" {
    .ppl-latest = [ SHELL "'$(INTRO_ROOT_DIR)/ppl/latest.sh' || echo -n error" ] ;
    if "$(.ppl-latest)" = "error" {
      errors.error "failed to extract PPL latest version." ;
    }
  }
  return "$(.ppl-latest)" ;
}

local rule get-isl-latest-version ( )
{
  if ! "$(.isl-latest)" {
    .isl-latest = [ SHELL "\"$(INTRO_ROOT_DIR)/isl/latest.sh\" || echo -n error" ] ;
    if "$(.isl-latest)" = "error" {
      errors.error "failed to extract isl latest version." ;
    }
  }
  return "$(.isl-latest)" ;
}

local rule get-cloog-latest-version ( )
{
  if ! "$(.cloog-latest)" {
    .cloog-latest = [ SHELL "\"$(INTRO_ROOT_DIR)/cloog/latest.sh\" || echo -n error" ] ;
    if "$(.cloog-latest)" = "error" {
      errors.error "failed to extract CLooG latest version." ;
    }
  }
  return "$(.cloog-latest)" ;
}

local rule get-icu4c-latest-version ( )
{
  if ! "$(.icu4c-latest)" {
    .icu4c-latest = [ SHELL "'$(INTRO_ROOT_DIR)/icu4c/latest.sh' || echo -n error" ] ;
    if "$(.icu4c-latest)" = "error" {
      errors.error "failed to extract ICU4C latest version." ;
    }
  }
  return "$(.icu4c-latest)" ;
}

local rule get-openmpi-latest-version ( )
{
  if ! "$(.openmpi-latest)" {
    .openmpi-latest = [ SHELL "'$(INTRO_ROOT_DIR)/openmpi/latest.sh' || echo -n error" ] ;
    if "$(.openmpi-latest)" = "error" {
      errors.error "failed to extract OpenMPI latest version." ;
    }
  }
  return "$(.openmpi-latest)" ;
}

local rule get-valgrind-latest-version ( )
{
  if ! "$(.valgrind-latest)" {
    .valgrind-latest = [ SHELL "\"$(INTRO_ROOT_DIR)/valgrind/latest.sh\" || echo -n error" ] ;
    if "$(.valgrind-latest)" = "error" {
      errors.error "failed to extract Valgrind latest version." ;
    }
  }
  return "$(.valgrind-latest)" ;
}



local binutils ;
local compilers ;
local gmp-versions ;
local mpfr-versions ;
local mpc-versions ;
local isl-versions ;
local cloog-versions ;
local icu4c-versions ;
local boost-versions ;
local clang-versions ;


local prefix = [ option.get "prefix" ] ;
if ! "$(prefix)" {
  errors.error "ERROR: '--prefix' option not specified." ;
}
ECHO prefix... $(prefix) ;


binutils = [ option.get "with-binutils" : "system" : "IMPLIED" ] ;
if "$(binutils)" = "IMPLIED" {
  errors.error "no value specified for `--with-binutils'." ;
}
if "$(binutils)" = "latest" {
  binutils = [ get-binutils-latest-version ] ;
}
if "$(binutils)" != "system" && ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(binutils)" : 1 ] {
  errors.error "an invalid value `$(binutils)' for `--with-binutils'." ;
}
ECHO binutils... $(binutils) ;


local gmp-for-gcc = [ option.get "with-gmp-for-gcc" : "latest" : "IMPLIED" ] ;
if "$(gmp-for-gcc)" = "IMPLIED" {
  errors.error "`--with-gmp-for-gcc' should be specified with a value." ;
}
if "$(gmp-for-gcc)" = "latest" {
  gmp-for-gcc = [ get-gmp-latest-version ] ;
}
if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(gmp-for-gcc)" : 1 ] {
  errors.error "an invalid value `$(gmp-for-gcc)' for `--with-gmp-for-gcc'." ;
}
if ! "$(gmp-for-gcc)" in $(gmp-versions) {
  gmp-versions += "$(gmp-for-gcc)" ;
}
ECHO gmp-for-gcc... $(gmp-for-gcc) ;


local mpfr-for-gcc = [ option.get "with-mpfr-for-gcc" : "latest" : "IMPLIED" ] ;
if "$(mpfr-for-gcc)" = "IMPLIED" {
  errors.error "`--with-mpfr-for-gcc' should be specified with a value." ;
}
if "$(mpfr-for-gcc)" = "latest" {
  mpfr-for-gcc = [ get-mpfr-latest-version ] ;
}
if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(mpfr-for-gcc)" : 1 ] {
  errors.error "an invalid value `$(mpfr-for-gcc)' for `--with-mpfr-for-gcc'." ;
}
if ! "$(mpfr-for-gcc)" in $(mpfr-versions) {
  mpfr-versions += "$(mpfr-for-gcc)" ;
}
ECHO mpfr-for-gcc... $(mpfr-for-gcc) ;


local mpc-for-gcc = [ option.get "with-mpc-for-gcc" : "latest" : "IMPLIED" ] ;
if "$(mpc-for-gcc)" = "IMPLIED" {
  errors.error "`--with-mpc-for-gcc' should be specified with a value." ;
}
if "$(mpc-for-gcc)" = "latest" {
  mpc-for-gcc = [ get-mpc-latest-version ] ;
}
if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(mpc-for-gcc)" : 1 ] {
  errors.error "an invalid value `$(mpc-for-gcc)' for `--with-mpc-for-gcc'." ;
}
if ! "$(mpc-for-gcc)" in $(mpc-versions) {
  mpc-versions += "$(mpc-for-gcc)" ;
}
ECHO mpc-for-gcc... $(mpc-for-gcc) ;


local isl-for-gcc = [ option.get "with-isl-for-gcc" : "system" : "IMPLIED" ] ;
if "$(isl-for-gcc)" = "IMPLIED" {
  errors.error "`--with-isl-for-gcc' should be specified with a value." ;
}
if "$(isl-for-gcc)" = "latest" {
  isl-for-gcc = [ get-isl-latest-version ] ;
}
if "$(isl-for-gcc)" != "system" && ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(isl-for-gcc)" : 1 ] {
  errors.error "an invalid value `$(isl-for-gcc)' for `--with-isl-for-gcc'." ;
}
if "$(isl-for-gcc)" != "system" && ! "$(isl-for-gcc)" in $(isl-versions)
{
  isl-versions += "$(isl-for-gcc)" ;
}
ECHO isl-for-gcc... $(isl-for-gcc) ;


local cloog-for-gcc = [ option.get "with-cloog-for-gcc" : "system" : "IMPLIED" ] ;
if "$(cloog-for-gcc)" = "IMPLIED" {
  errors.error "`--with-cloog-for-gcc' should be specified with a value." ;
}
if "$(cloog-for-gcc)" = "latest" {
  cloog-for-gcc = [ get-cloog-latest-version ] ;
}
if "$(cloog-for-gcc)" != "system" && ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(cloog-for-gcc)" : 1 ] {
  errors.error "an invalid value `$(cloog-for-gcc)' for `--with-cloog-for-gcc'." ;
}
if "$(cloog-for-gcc)" != "system" && ! "$(cloog-for-gcc)" in $(cloog-versions) {
  cloog-versions += "$(cloog-for-gcc)" ;
}
ECHO cloog-for-gcc... $(cloog-for-gcc) ;


local enabled-compilers = [ option.get enable-compilers : : "IMPLIED" ] ;
if "$(enabled-compilers)" = "IMPLIED" {
  errors.error "`--enable-compilers' should be specified with a value." ;
}
if ! "$(enabled-compilers)" {
  errors.error "`--enable-compilers' option is required." ;
}
enabled-compilers = [ regex.split "$(enabled-compilers)" "," ] ;
for local enabled-compiler in $(enabled-compilers) {
  if ! [ is-valid "$(enabled-compiler)" ] {
    errors.error "an invalid value `$(enabled-compiler)' for `--enable-compilers' option." ;
  }
  ECHO "enabled-compiler... $(enabled-compiler)" ;
  if ! "$(enabled-compiler)" in $(compilers) {
    compilers += "$(enabled-compiler)" ;
  }
  if [ is-clang "$(enabled-compiler)" ] {
    local frontend-and-backend = [ split-frontend-and-backend "$(enabled-compiler)" ] ;
    local frontend = "$(frontend-and-backend[1])" ;
    local backend = "$(frontend-and-backend[2])" ;
    if "$(frontend)" = "clang-trunk" {
      if ! "trunk" in $(clang-versions) {
        clang-versions += "trunk" ;
      }
    }
    else {
      local version = [ get-frontend-version "$(enabled-compiler)" ] ;
      if ! "$(version)" in $(clang-versions) {
        clang-versions += "$(version)" ;
      }
    }
    if ! "$(backend)" {
      errors.error "an internal error." ;
    }
    compilers += "$(backend)" ;
  }
  if [ is-icc "$(enabled-compiler)" ] {
    local backend-gcc = [ get-backend-gcc "$(enabled-compiler)" ] ;
    if ! "$(backend-gcc)" in $(compilers) {
      compilers += "$(backend-gcc)" ;
    }
  }
}


local multitarget = [ option.get "enable-multitarget" : "IMPLIED" : "yes" ] ;
if ! "$(multitarget)" in IMPLIED no yes {
  errors.error "ERROR: `$(multitarget)' is a wrong value for `--enable-multitarget' option." ;
}
if [ option.get "disable-multitarget" : "IMPLIED" : "IMPLIED" ] != "IMPLIED" {
  errors.error "no value for `--disable-multitarget' is allowed." ;
}
if [ option.get "disable-multitarget" : : "IMPLIED" ] = "IMPLIED" {
  if "$(multitarget)" = "yes" {
    errors.error "ERROR: both `--enable-multitarget' and `--disable-multitarget' are specified." ;
  }
  else if "$(multitarget)" = "no" {
    # Do nothing.
  }
  else if "$(multitarget)" = "IMPLIED" {
    multitarget = "no" ;
  }
  else {
    errors.error "an internal error." ;
  }
}
if "$(multitarget)" = "IMPLIED" {
  multitarget = "yes" ;
}
ECHO multitarget... $(multitarget) ;


local with-gold = [ option.get "with-gold" : "UNSPECIFIED" : "IMPLIED" ] ;
switch "$(with-gold)" {
case "UNSPECIFIED" :
  with-gold = [ option.get "without-gold" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(with-gold)" {
  case "UNSPECIFIED" :
    with-gold = "no" ;
  case "IMPLIED" :
    with-gold = "no" ;
  case "*" :
    errors.error "`--without-gold' cannot have any value." ;
  }
case "IMPLIED" :
  with-gold = [ option.get "without-gold" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(with-gold)" {
  case "UNSPECIFIED" :
    with-gold = "yes" ;
  case "IMPLIED" :
    errors.error "`--with-gold' and `--without-gold' cannot be specified simultaneously." ;
  case "*" :
    errors.error "`--without-gold' cannot have any value." ;
  }
case "yes" :
  with-gold = [ option.get "without-gold" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(with-gold)" {
  case "UNSPECIFIED" :
    with-gold = "yes" ;
  case "IMPLIED" :
    errors.error "`--with-gold' and `--without-gold' cannot be specified simultaneously." ;
  case "*" :
    errors.error "`--without-gold' cannot have any value." ;
  }
case "no" :
  with-gold = [ option.get "without-gold" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(with-gold)" {
  case "UNSPECIFIED" :
    with-gold = "no" ;
  case "IMPLIED" :
    errors.error "`--with-gold' and `--without-gold' cannot be specified simultaneously." ;
  case "*" :
    errors.error "`--without-gold' cannot have any value." ;
  }
case "" :
  errors.error "the value for `--with-gold' is an empty string." ;
case "*" :
  errors.error "an invalid value `$(with-gold)' is specified for `--with-gold'." ;
}
ECHO with-gold... $(with-gold) ;


local gcc-check = [ option.get "with-gcc-check" : "UNSPECIFIED" : "IMPLIED" ] ;
switch "$(gcc-check)" {
case "UNSPECIFIED" :
  gcc-check = [ option.get "without-gcc-check" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(gcc-check)" {
  case "UNSPECIFIED" :
    gcc-check = "yes" ;
  case "IMPLIED" :
    gcc-check = "no" ;
  case "*" :
    errors.error "`--without-gcc-check' cannot have any value." ;
  }
case "IMPLIED" :
  gcc-check = [ option.get "without-gcc-check" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(gcc-check)" {
  case "UNSPECIFIED" :
    gcc-check = "yes" ;
  case "IMPLIED" :
    errors.error "`--with-gcc-check' and `--without-gcc-check' cannot be specified simultaneously." ;
  case "*" :
    errors.error "`--without-gcc-check' cannot have any value." ;
  }
case "yes" :
  gcc-check = [ option.get "without-gcc-check" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(gcc-check)" {
  case "UNSPECIFIED" :
    gcc-check = "yes" ;
  case "IMPLIED" :
    errors.error "`--with-gcc-check' and `--without-gcc-check' cannot be specified simultaneously." ;
  case "*" :
    errors.error "`--without-gcc-check' cannot have any value." ;
  }
case "no" :
  gcc-check = [ option.get "without-gcc-check" : "UNSPECIFIED" : "IMPLIED" ] ;
  switch "$(gcc-check)" {
  case "UNSPECIFIED" :
    gcc-check = "no" ;
  case "IMPLIED" :
    errors.error "`--with-gcc-check' and `--without-gcc-check' cannot be specified simultaneously." ;
  case "*" :
    errors.error "`--without-gcc-check' cannot have any value." ;
  }
case "" :
  errors.error "the value for `--with-gcc-check' is an empty string." ;
case "*" :
  errors.error "an invalid value `$(gcc-check)' is specified for `--with-gcc-check'." ;
}
ECHO gcc-check... $(gcc-check) ;


local lcov = [ option.get "enable-lcov" : : "latest" ] ;
if "$(lcov)" = latest {
  lcov = [ get-lcov-latest-version ] ;
}
if "$(lcov)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+)?)$" : "$(lcov)" : 1 ] {
    errors.error "an invalid value `$(lcov)' for `--enable-lcov'." ;
  }
  ECHO "lcov... $(lcov)" ;
}
else {
  ECHO "lcov... N/A" ;
}


local gcovr = [ option.get "enable-gcovr" : : "latest" ] ;
if "$(gcovr)" = latest {
  gcovr = [ get-gcovr-latest-version ] ;
}
if "$(gcovr)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(gcovr)" : 1 ] {
    errors.error "an invalid value `$(gcovr)' for `--enable-gcovr'." ;
  }
  ECHO "gcovr... $(gcovr)" ;
}
else {
  ECHO "gcovr... N/A" ;
}


local gmp = [ option.get "enable-gmp" : : "latest" ] ;
if "$(gmp)" = "latest" {
  gmp = [ get-gmp-latest-version ] ;
}
if "$(gmp)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(gmp)" : 1 ] {
    errors.error "an invalid value `$(gmp)' for `--enable-gmp'." ;
  }
  if ! "$(gmp)" in $(gmp-versions) {
    gmp-versions += "$(gmp)" ;
  }
  ECHO gmp... $(gmp) ;
}


local mpfr = [ option.get "enable-mpfr" : : "latest" ] ;
if "$(mpfr)" = "latest" {
  mpfr = [ get-mpfr-latest-version ] ;
}
if "$(mpfr)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(mpfr)" : 1 ] {
    errors.error "an invalid value `$(mpfr)' for `--enable-mpfr'." ;
  }
  if ! "$(mpfr)" in $(mpfr-versions) {
    mpfr-versions += "$(mpfr)" ;
  }
  ECHO mpfr... $(mpfr) ;
  if ! "$(gmp)" {
    gmp = [ get-gmp-latest-version ] ;
    if ! "$(gmp)" in $(gmp-versions) {
      gmp-versions += "$(gmp)" ;
    }
    ECHO gmp... $(gmp) (implied by '--enable-mpfr') ;
  }
}


local mpc = [ option.get "enable-mpc" : : "latest" ] ;
if "$(mpc)" = "latest" {
  mpc = [ get-mpc-latest-version ] ;
}
if "$(mpc)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(mpc)" : 1 ] {
    errors.error "an invalid value `$(mpc)' for `--enable-mpc'." ;
  }
  if ! "$(mpc)" in $(mpc-versions) {
    mpc-versions += "$(mpc)" ;
  }
  ECHO mpc... $(mpc) ;
  if ! "$(gmp)" {
    gmp = [ get-gmp-latest-version ] ;
    if ! "$(gmp)" in $(gmp-versions) {
      gmp-versions += "$(gmp)" ;
    }
    ECHO gmp... $(gmp) (implied by '--enable-mpc') ;
  }
  if ! "$(mpfr)" {
    mpfr = [ get-mpfr-latest-version ] ;
    if ! "$(mpfr)" in $(mpfr-versions) {
      mpfr-versions += "$(mpfr)" ;
    }
    ECHO mpfr... $(mpfr) (implied by `--enable-mpc') ;
  }
}


local ppl = [ option.get "enable-ppl" : : "latest" ] ;
if "$(ppl)" = "latest" {
  ppl = [ get-ppl-latest-version ] ;
}
if "$(ppl)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(ppl)" : 1 ] {
    errors.error "an invalid value `$(ppl)' for `--enable-ppl'." ;
  }
  ECHO ppl... $(ppl) ;
  if ! "$(gmp)" {
    gmp = [ get-gmp-latest-version ] ;
    if ! "$(gmp)" in $(gmp-versions) {
      gmp-versions += "$(gmp)" ;
    }
    ECHO gmp... $(gmp) (implied by --enable-ppl) ;
  }
}


local isl = [ option.get "enable-isl" : : "latest" ] ;
if "$(isl)" = "latest" {
  isl = [ get-isl-latest-version ] ;
}
if "$(isl)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(isl)" : 1 ] {
    errors.error "an invalid value `$(isl)' for `--enable-isl'." ;
  }
  if ! "$(isl)" in $(isl-versions) {
    isl-versions += "$(isl)" ;
  }
  ECHO isl... $(isl) ;
  if ! "$(gmp)" {
    gmp = [ get-gmp-latest-version ] ;
    if ! "$(gmp)" in $(gmp-versions) {
      gmp-versions += "$(gmp)" ;
    }
    ECHO gmp... $(gmp) (implied by --enable-isl) ;
  }
}


local cloog = [ option.get enable-cloog : : latest ] ;
if $(cloog) = latest
{
  cloog = [ get-cloog-latest-version ] ;
}
if $(cloog)
{
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(cloog)" : 1 ] {
    errors.error "an invalid value `$(cloog)' for `--enable-cloog'." ;
  }
  if ! "$(cloog)" in $(cloog-versions) {
    cloog-versions += "$(cloog)" ;
  }
  ECHO cloog... $(cloog) ;
  if ! "$(gmp)" {
    gmp = [ get-gmp-latest-version ] ;
    if ! "$(gmp)" in $(gmp-versions) {
      gmp-versions += "$(gmp)" ;
    }
    ECHO gmp... $(gmp) (implied by --enable-cloog) ;
  }
  if ! "$(isl)" {
    isl = [ get-isl-latest-version ] ;
    if ! "$(isl)" in $(isl-versions) {
      isl-versions += "$(isl)" ;
    }
    ECHO isl... $(isl) (implied by --enable-cloog) ;
  }
}


local icu4c = [ option.get "enable-icu4c" : : "latest" ] ;
if "$(icu4c)" = "latest" {
  icu4c = [ get-icu4c-latest-version ] ;
}
if "$(icu4c)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)?)$" : "$(icu4c)" : 1 ] {
    errors.error "an invalid value `$(icu4c)' for `--enable-icu4c'." ;
  }
  if ! "$(icu4c)" in $(icu4c-versions) {
    icu4c-versions += "$(icu4c)" ;
  }
  ECHO icu4c... $(icu4c) ;
}


local openmpi = [ option.get "enable-openmpi" : : "latest" ] ;
if "$(openmpi)" = "latest" {
  openmpi = [ get-openmpi-latest-version ] ;
}
if "$(openmpi)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(openmpi)" : 1 ] {
    errors.error "an invalid value `$(openmpi)' for `--enable-openmpi'." ;
  }
  ECHO openmpi... $(openmpi) ;
}


local mpi-backend = [ option.get with-mpi-backend : unspecified : IMPLIED ] ;
if "$(mpi-backend)" = "IMPLIED" {
  errors.error "ERROR: No value is specified for `--with-mpi-backend' option." ;
}
if ! "$(mpi-backend)" in openmpi mpich2 unspecified {
  errors.error "ERROR: `$(mpi-backend)' is a wrong value for `--with-mpi-backend' option.\n"
               "             Allowed values are `openmpi' or `mpich2'." ;
}
if "$(mpi-backend)" = "unspecified" && "$(openmpi)" {
  mpi-backend = "openmpi" ;
}
if "$(mpi-backend)" = "openmpi" {
  if ! "$(openmpi)" {
    openmpi = [ get-openmpi-latest-version ] ;
    ECHO openmpi... $(openmpi) (implied by --with-mpi-backend=openmpi) ;
  }
}
ECHO mpi backend... $(mpi-backend) ;


local boost = [ option.get "enable-boost" : : "latest" ] ;
if "$(boost)" = "latest" {
  boost = [ get-boost-latest-version ] ;
}
if "$(boost)" {
  if ! [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(boost)" : 1 ] {
    errors.error "an invalid value `$(boost)' for `--enable-boost'." ;
  }
  if ! "$(boost)" in $(boost-versions) {
    boost-versions += "$(boost)" ;
  }
}
if "$(boost-versions)" {
  ECHO boost-versions... $(boost-versions) ;
}
else {
  ECHO boost-versions... N/A ;
}


local clang = [ option.get "enable-clang" : : "latest" ] ;
if "$(clang)" = "latest" {
  clang = [ get-clang-latest-version ] ;
}
if "$(clang)" {
  if [ regex.match "^([0-9]+\\.[0-9]+)$" : "$(clang)" : 1 ] {
    # Do nothing.
  }
  else if "$(clang)" = "trunk" {
    # Do nothing.
  }
  else
  {
    errors.error "an invalid value `$(clang)' for `--enable-clang' option.\n" ;
  }
  ECHO clang... $(clang) ;
  if ! "$(clang)" in $(clang-versions) {
    clang-versions += "$(clang)" ;
  }
}
else {
  ECHO clang... N/A ;
}


local valgrind = [ option.get "enable-valgrind" : : "latest" ] ;
if "$(valgrind)" = "latest" {
  valgrind = [ get-valgrind-latest-version ] ;
}
if "$(valgrind)" {
  if [ regex.match "^([0-9]+(\\.[0-9]+(\\.[0-9]+)?)?)$" : "$(valgrind)" : 1 ] {
    # Do nothing.
  }
  else if "$(valgrind)" = "trunk" {
    # Do nothing.
  }
  else {
    errors.error "an invalid value `$(valgrind)' for `--enable-valgrind'." ;
  }
  ECHO valgrind... $(valgrind) ;
}
else {
  ECHO valgrind... N/A ;
}


local concurrency = [ option.get "concurrency" : "1" : "IMPLIED" ] ;
if "$(concurrency)" = "IMPLIED" {
  errors.error "ERROR: No value is specified for `--concurrency' option." ;
}
if ! [ regex.match "(^[1-9][0-9]*)" : "$(concurrency)" : 1 ] {
  errors.error "`$(concurrency)' is a wrong value for `--concurrency' option.'" ;
}
ECHO concurrency... $(concurrency) ;


local awacs = [ option.get "with-awacs" : : "IMPLIED" ] ;
if "$(awacs)" = "IMPLIED" {
  errors.error "No value for `--with-awacs' option is specified." ;
}
if "$(awacs)" {
  ECHO awacs... $(awacs) ;
}
else {
  ECHO awacs... N/A ;
}


local stdout = [ option.get "stdout" : : "IMPLIED" ] ;
if "$(stdout)" = "IMPLIED" {
  errors.error "option `--stdout' requires an argument" ;
}
if "$(stdout)" {
  ECHO --stdout... $(stdout) ;
}
else {
  stdout = "/dev/null" ;
  ECHO --stdout... /dev/null (default) ;
}


local stderr = [ option.get "stderr" : : "IMPLIED" ] ;
if "$(stderr)" = "IMPLIED" {
  errors.error "option `--stderr' requires an argument" ;
}
if "$(stderr)" {
  ECHO --stderr... $(stderr) ;
}
else {
  stderr = "/dev/null" ;
  ECHO --stderr... /dev/null (default) ;
}





project intro
  : default-build
    <variant>release
    <threading>multi
  : build-dir bin
  ;


constant PREFIX : "$(prefix)" ;
ECHO PREFIX... $(PREFIX) ;

if "$(binutils)" = "system" {
  binutils = ;
}
if "$(binutils)" {
  constant BINUTILS : "$(binutils)" ;
  ECHO BINUTILS... $(BINUTILS) ;
}
else {
  constant BINUTILS : "" ;
  ECHO BINUTILS... N/A ;
}

if "$(gmp-for-gcc)" {
  constant GMP_FOR_GCC : "$(gmp-for-gcc)" ;
  ECHO GMP_FOR_GCC... $(GMP_FOR_GCC) ;
}
else {
  constant GMP_FOR_GCC : "" ;
  ECHO GMP_FOR_GCC... N/A ;
}

if "$(mpfr-for-gcc)" {
  constant MPFR_FOR_GCC : "$(mpfr-for-gcc)" ;
  ECHO MPFR_FOR_GCC... $(MPFR_FOR_GCC) ;
}
else {
  constant MPFR_FOR_GCC : "" ;
  ECHO MPFR_FOR_GCC... N/A ;
}

if "$(mpc-for-gcc)" {
  constant MPC_FOR_GCC : "$(mpc-for-gcc)" ;
  ECHO MPC_FOR_GCC... $(MPC_FOR_GCC) ;
}
else {
  constant MPC_FOR_GCC : "" ;
  ECHO MPC_FOR_GCC... N/A ;
}

if "$(isl-for-gcc)" = "system" {
  isl-for-gcc = ;
}
if "$(isl-for-gcc)" {
  constant ISL_FOR_GCC : "$(isl-for-gcc)" ;
  ECHO ISL_FOR_GCC... $(ISL_FOR_GCC) ;
}
else {
  constant ISL_FOR_GCC : "" ;
  ECHO ISL_FOR_GCC... N/A ;
}

if "$(cloog-for-gcc)" = "system" {
  cloog-for-gcc = ;
}
if "$(cloog-for-gcc)" {
  constant CLOOG_FOR_GCC : "$(cloog-for-gcc)" ;
  ECHO CLOOG_FOR_GCC... $(CLOOG_FOR_GCC) ;
}
else {
  constant CLOOG_FOR_GCC : "" ;
  ECHO CLOOG_FOR_GCC... N/A ;
}

constant COMPILERS : $(compilers) ;
ECHO COMPILERS... $(COMPILERS) ;

constant WITH_GOLD : "$(with-gold)" ;
ECHO WITH_GOLD... $(WITH_GOLD) ;

constant GCC_CHECK : "$(gcc-check)" ;
ECHO GCC_CHECK... $(GCC_CHECK) ;

if "$(lcov)" {
  constant LCOV : "$(lcov)" ;
  ECHO "LCOV... $(LCOV)" ;
}
else {
  ECHO "LCOV... N/A" ;
}

if "$(gcovr)" {
  constant GCOVR : "$(gcovr)" ;
  ECHO "GCOVR... $(GCOVR)" ;
}
else {
  ECHO "GCOVR... N/A" ;
}

if $(gmp-versions) {
  constant GMP_VERSIONS : $(gmp-versions) ;
  ECHO GMP_VERSIONS... $(GMP_VERSIONS:J=,) ;
}

if $(mpfr-versions) {
  constant MPFR_VERSIONS : $(mpfr-versions) ;
  ECHO MPFR_VERSIONS... $(MPFR_VERSIONS:J=,) ;
}

if $(mpc-versions) {
  constant MPC_VERSIONS : $(mpc-versions) ;
  ECHO MPC_VERSIONS... $(MPC_VERSIONS:J=,) ;
}

if $(isl-versions) {
  constant ISL_VERSIONS : $(isl-versions) ;
  ECHO ISL_VERSIONS... $(ISL_VERSIONS:J=,) ;
}
else {
  ECHO ISL_VERSIONS... N/A ;
}

if $(cloog-versions) {
  constant CLOOG_VERSIONS : $(cloog-versions) ;
  ECHO CLOOG_VERSIONS... $(CLOOG_VERSIONS:J=,) ;
}
else {
  ECHO CLOOG_VERSIONS... N/A ;
}

if "$(ppl)" {
  constant PPL : "$(ppl)" ;
  ECHO PPL... $(PPL) ;
}
else {
  ECHO PPL... N/A ;
}

if $(icu4c-versions) {
  constant ICU4C_VERSIONS : $(icu4c-versions) ;
  ECHO ICU4C_VERSIONS... $(ICU4C_VERSIONS:J=,) ;
}
else {
  ECHO ICU4C_VERSIONS... N/A ;
}

if "$(openmpi)" {
  constant OPENMPI : "$(openmpi)" ;
  ECHO OPENMPI... $(OPENMPI) ;
}
else {
  ECHO OPENMPI... N/A ;
}

if $(boost-versions) {
  constant BOOST_VERSIONS : $(boost-versions) ;
  ECHO BOOST_VERSIONS... $(BOOST_VERSIONS:J=,) ;
}

if "$(clang)" {
  constant CLANG : "$(clang)" ;
  ECHO CLANG... $(clang) ;
}
else {
  ECHO CLANG... N/A ;
}

if $(clang-versions) {
  constant CLANG_VERSIONS : $(clang-versions) ;
  ECHO CLANG_VERSIONS... $(clang-versions:J=,) ;
}
else {
  ECHO CLANG_VERSIONS... N/A ;
}

if "$(valgrind)" {
  constant VALGRIND : "$(valgrind)" ;
  ECHO VALGRIND... $(valgrind) ;
}
else {
  ECHO VALGRIND... N/A ;
}

constant CONCURRENCY : "$(concurrency)" ;
ECHO CONCURRENCY... $(CONCURRENCY) ;

if "$(awacs)" {
  constant AWACS : "$(awacs)" ;
  ECHO AWACS... $(AWACS) ;
}
else {
  constant AWACS : "cat > /dev/null" ;
  ECHO AWACS... N/A ;
}

constant STDOUT_ : "$(stdout)" ;
ECHO STDOUT_... $(STDOUT_) ;

constant STDERR_ : "$(stderr)" ;
ECHO STDERR_... $(STDERR_) ;



feature compiler        : unspecified $(compilers)      :                       ;
feature compiler-hidden : [ feature.values <compiler> ] : propagated incidental ;
{
  local use-compiler ;
  for local val in [ feature.values <compiler> ] {
    use-compiler += <compiler-hidden>$(val):<compiler>$(val) ;
  }
  constant USE_COMPILER : $(use-compiler) ;
}

feature multitarget        : unspecified no yes               :                       ;
feature multitarget-hidden : [ feature.values <multitarget> ] : propagated incidental ;
{
  local use-multitarget ;
  for local val in [ feature.values <multitarget> ] {
    use-multitarget += <multitarget-hidden>$(val):<multitarget>$(val) ;
  }
  constant USE_MULTITARGET : $(use-multitarget) ;
}

feature binutils        : unspecified $(binutils)       :                       ;
feature binutils-hidden : [ feature.values <binutils> ] : propagated incidental ;
{
  local use-binutils ;
  for local val in [ feature.values <binutils> ] {
    use-binutils += <binutils-hidden>$(val):<binutils>$(val) ;
  }
  constant USE_BINUTILS : $(use-binutils) ;
}

feature gmp-for-gcc        : unspecified $(gmp-for-gcc)       :                       ;
feature gmp-for-gcc-hidden : [ feature.values <gmp-for-gcc> ] : propagated incidental ;
{
  local use-gmp-for-gcc ;
  for local val in [ feature.values <gmp-for-gcc> ] {
    use-gmp-for-gcc += <gmp-for-gcc-hidden>$(val):<gmp-for-gcc>$(val) ;
  }
  constant USE_GMP_FOR_GCC : $(use-gmp-for-gcc) ;
}

feature mpfr-for-gcc        : unspecified $(mpfr-for-gcc)       :                       ;
feature mpfr-for-gcc-hidden : [ feature.values <mpfr-for-gcc> ] : propagated incidental ;
{
  local use-mpfr-for-gcc ;
  for local val in [ feature.values <mpfr-for-gcc> ] {
    use-mpfr-for-gcc += <mpfr-for-gcc-hidden>$(val):<mpfr-for-gcc>$(val) ;
  }
  constant USE_MPFR_FOR_GCC : $(use-mpfr-for-gcc) ;
}

feature mpc-for-gcc        : unspecified $(mpc-for-gcc)       :                       ;
feature mpc-for-gcc-hidden : [ feature.values <mpc-for-gcc> ] : propagated incidental ;
{
  local use-mpc-for-gcc ;
  for local val in [ feature.values <mpc-for-gcc> ] {
    use-mpc-for-gcc += <mpc-for-gcc-hidden>$(val):<mpc-for-gcc>$(val) ;
  }
  constant USE_MPC_FOR_GCC : $(use-mpc-for-gcc) ;
}

feature isl-for-gcc        : unspecified $(isl-for-gcc)       :                       ;
feature isl-for-gcc-hidden : [ feature.values <isl-for-gcc> ] : propagated incidental ;
{
  local use-isl-for-gcc ;
  for local val in [ feature.values <isl-for-gcc> ] {
    use-isl-for-gcc += <isl-for-gcc-hidden>$(val):<isl-for-gcc>$(val) ;
  }
  constant USE_ISL_FOR_GCC : $(use-isl-for-gcc) ;
}

feature cloog-for-gcc        : unspecified $(cloog-for-gcc)       :                       ;
feature cloog-for-gcc-hidden : [ feature.values <cloog-for-gcc> ] : propagated incidental ;
{
  local use-cloog-for-gcc ;
  for local val in [ feature.values <cloog-for-gcc> ] {
    use-cloog-for-gcc += <cloog-for-gcc-hidden>$(val):<cloog-for-gcc>$(val) ;
  }
  constant USE_CLOOG_FOR_GCC : $(use-cloog-for-gcc) ;
}

feature lcov        : unspecified $(lcov)       :                       ;
feature lcov-hidden : [ feature.values <lcov> ] : propagated incidental ;
{
  local use-lcov ;
  for local val in [ feature.values <lcov> ] {
    use-lcov += <lcov-hidden>$(val):<lcov>$(val) ;
  }
  constant USE_LCOV : $(use-lcov) ;
}

feature gcovr        : unspecified $(gcovr)       :                       ;
feature gcovr-hidden : [ feature.values <gcovr> ] : propagated incidental ;
{
  local use-gcovr ;
  for local val in [ feature.values <gcovr> ] {
    use-gcovr += <gcovr-hidden>$(val):<gcovr>$(val) ;
  }
  constant USE_GCOVR : $(use-gcovr) ;
}

feature gmp        : unspecified $(gmp-versions) :                       ;
feature gmp-hidden : [ feature.values <gmp> ]    : propagated incidental ;
{
  local use-gmp ;
  for local val in [ feature.values <gmp> ] {
    use-gmp += <gmp-hidden>$(val):<gmp>$(val) ;
  }
  constant USE_GMP : $(use-gmp) ;
}

feature mpfr        : unspecified $(mpfr-versions) :                       ;
feature mpfr-hidden : [ feature.values <mpfr> ]    : propagated incidental ;
{
  local use-mpfr ;
  for local val in [ feature.values <mpfr> ] {
    use-mpfr += <mpfr-hidden>$(val):<mpfr>$(val) ;
  }
  constant USE_MPFR : $(use-mpfr) ;
}

feature mpc        : unspecified $(mpc-versions) :                       ;
feature mpc-hidden : [ feature.values <mpc> ]    : propagated incidental ;
{
  local use-mpc ;
  for local val in [ feature.values <mpc> ] {
    use-mpc += <mpc-hidden>$(val):<mpc>$(val) ;
  }
  constant USE_MPC : $(use-mpc) ;
}

feature ppl        : unspecified $(ppl)       :                       ;
feature ppl-hidden : [ feature.values <ppl> ] : propagated incidental ;
{
  local use-ppl ;
  for local val in [ feature.values <ppl> ] {
    use-ppl += <ppl-hidden>$(val):<ppl>$(val) ;
  }
  constant USE_PPL : $(use-ppl) ;
}

feature isl        : unspecified $(isl-versions) :                       ;
feature isl-hidden : [ feature.values <isl> ]    : propagated incidental ;
{
  local use-isl ;
  for local val in [ feature.values <isl> ] {
    use-isl += <isl-hidden>$(val):<isl>$(val) ;
  }
  constant USE_ISL : $(use-isl) ;
}

feature cloog        : unspecified $(cloog-versions) :                       ;
feature cloog-hidden : [ feature.values <cloog> ]    : propagated incidental ;
{
  local use-cloog ;
  for local val in [ feature.values <cloog> ] {
    use-cloog += <cloog-hidden>$(val):<cloog>$(val) ;
  }
  constant USE_CLOOG : $(use-cloog) ;
}

feature icu4c        : unspecified $(icu4c-versions) :                       ;
feature icu4c-hidden : [ feature.values <icu4c> ]    : propagated incidental ;
{
  local use-icu4c ;
  for local val in [ feature.values <icu4c> ] {
    use-icu4c += <icu4c-hidden>$(val):<icu4c>$(val) ;
  }
  constant USE_ICU4C : $(use-icu4c) ;
}

feature openmpi        : unspecified $(openmpi)       :                       ;
feature openmpi-hidden : [ feature.values <openmpi> ] : propagated incidental ;
{
  local use-openmpi ;
  for local val in [ feature.values <openmpi> ] {
    use-openmpi += <openmpi-hidden>$(val):<openmpi>$(val) ;
  }
  constant USE_OPENMPI : $(use-openmpi) ;
}

feature mpi-backend        : unspecified openmpi mpich2         :                       ;
feature mpi-backend-hidden : [ feature.values <mpi-backend> ]   : propagated incidental ;
{
  local use-mpi-backend ;
  for local val in [ feature.values <mpi-backend> ] {
    use-mpi-backend += <mpi-backend-hidden>$(val):<mpi-backend>$(val) ;
  }
  constant USE_MPI_BACKEND : $(use-mpi-backend) ;
}

feature boost        : unspecified $(boost-versions) :                       ;
feature boost-hidden : [ feature.values <boost> ]    : propagated incidental ;
{
  local use-boost ;
  for local val in [ feature.values <boost> ] {
    use-boost += <boost-hidden>$(val):<boost>$(val) ;
  }
  constant USE_BOOST : $(use-boost) ;
}

feature clang        : unspecified $(clang)       :                       ;
feature clang-hidden : [ feature.values <clang> ] : propagated incidental ;
{
  local use-clang ;
  for local val in [ feature.values <clang> ] {
    use-clang += <clang-hidden>$(val):<clang>$(val) ;
  }
  constant USE_CLANG : $(use-clang) ;
}

feature valgrind        : unspecified $(valgrind)       :                       ;
feature valgrind-hidden : [ feature.values <valgrind> ] : propagated incidental ;
{
  local use-valgrind ;
  for local val in [ feature.values <valgrind> ] {
    use-valgrind += <valgrind-hidden>$(val):<valgrind>$(val) ;
  }
  constant USE_VALGRIND : $(use-valgrind) ;
}

feature intro-address-model          : 64 32                                    : propagated incidental ;
feature intro-address-model-on-build : [ feature.values <intro-address-model> ] :                       ;
{
  local use-address-model ;
  for local val in [ feature.values <intro-address-model> ] {
    use-address-model += <intro-address-model>$(val):<intro-address-model-on-build>$(val) ;
  }
  constant USE_ADDRESS_MODEL : $(use-address-model) ;
}

local default-bits = [ get-default-bits ] ;
switch "$(default-bits)" {
case "64" :
  feature.set-default "intro-address-model" : "64" ;
case "32" :
  feature.set-default "intro-address-model" : "32" ;
case "" :
  errors.error "the value for `<intro-address-model>' feature is empty" ;
case "*" :
  errors.error "`<intro-address-model>$(default-bits)': unknown property" ;
}

feature intro-instruction-set          : unspecified native                         : propagated incidental ;
feature intro-instruction-set-on-build : [ feature.values <intro-instruction-set> ] :                       ;
{
  local use-instruction-set ;
  for local val in [ feature.values <intro-instruction-set> ] {
    use-instruction-set += <intro-instruction-set>$(val):<intro-instruction-set-on-build>$(val) ;
  }
  constant USE_INSTRUCTION_SET : $(use-instruction-set) ;
}

local default-host-os = [ feature.get-values "<host-os>" : [ feature.defaults "<host-os>" ] ] ;
constant DEFAULT_COMPILER_PROPERTIES : "<variant>release/<link>shared/<runtime-link>shared/<runtime-debugging>off/<optimization>speed/<profiling>off/<inlining>full/<threading>multi/<intro-address-model>$(default-bits)/<intro-instruction-set>unspecified/<std>c++03/<lto>off/<correct-call-stack>off/<ssp>off/<memory-checker>off/<libstdc++-debug-mode>off" ;
constant DEFAULT_PROPERTIES : "<host-os>$(default-host-os)/<target-os>$(default-host-os)/<variant>debug/<std>c++03/<link>shared/<runtime-link>shared/<runtime-debugging>on/<optimization>off/<profiling>off/<inlining>off/<threading>single/<intro-address-model>$(default-bits)/<intro-instruction-set>unspecified/<lto>off/<correct-call-stack>off/<ssp>off/<memory-checker>off/<libstdc++-debug-mode>off" ;
constant ADDRESS_MODEL_SENSIBLE_DEFAULT_RELEASE_PROPERTIES : "<variant>release/<link>shared/<runtime-link>shared/<threading>multi/<intro-instruction-set>unspecified/<std>c++03/<lto>off/<memory-checker>off/<libstdc++-debug-mode>off" ;

for local enabled-compiler in $(enabled-compilers) {
  local srcs ;
  if "$(lcov)" {
    srcs += "lcov//install" ;
  }
  if "$(gcovr)" {
    srcs += "gcovr//install" ;
  }
  if "$(gmp)" {
    srcs += "gmp//install" ;
  }
  if "$(mpfr)" {
    srcs += "mpfr//install" ;
  }
  if "$(mpc)" {
    srcs += "mpc//install" ;
  }
  if "$(ppl)" {
    srcs += "ppl//install" ;
  }
  if "$(isl)" {
    srcs += "isl//install" ;
  }
  if "$(cloog)" {
    srcs += "cloog//install" ;
  }
  if "$(icu4c)" {
    srcs += "icu4c//install" ;
  }
  if "$(openmpi)" {
    srcs += "openmpi//install" ;
  }
  if "$(boost)" {
    srcs += "boost//install" ;
  }
  if "$(valgrind)" {
    srcs += "valgrind//install" ;
  }

  if [ is-gcc "$(enabled-compiler)" ] {
    if "$(clang)" {
      srcs += "clang//install" ;
    }

    if ! "$(boost-versions)" {
      alias $(enabled-compiler)
      : gcc//install
        $(srcs)
      : <compiler-hidden>$(enabled-compiler)
        <multitarget-hidden>$(multitarget)
        <binutils-hidden>$(binutils)
        <gmp-for-gcc-hidden>$(gmp-for-gcc)
        <mpfr-for-gcc-hidden>$(mpfr-for-gcc)
        <mpc-for-gcc-hidden>$(mpc-for-gcc)
        <isl-for-gcc-hidden>$(isl-for-gcc)
        <cloog-for-gcc-hidden>$(cloog-for-gcc)
        <lcov-hidden>$(lcov)
        <gcovr-hidden>$(gcovr)
        <gmp-hidden>$(gmp)
        <mpfr-hidden>$(mpfr)
        <mpc-hidden>$(mpc)
        <isl-hidden>$(isl)
        <cloog-hidden>$(cloog)
        <ppl-hidden>$(ppl)
        <icu4c-hidden>$(icu4c)
        <openmpi-hidden>$(openmpi)
        <mpi-backend-hidden>$(mpi-backend)
        <clang-hidden>$(clang)
        <valgrind-hidden>$(valgrind)
      ;
    }
    else {
      for local boost in $(boost-versions) {
        alias $(enabled-compiler)
          : gcc//install
            $(srcs)
          : <compiler-hidden>$(enabled-compiler)
            <multitarget-hidden>$(multitarget)
            <binutils-hidden>$(binutils)
            <gmp-for-gcc-hidden>$(gmp-for-gcc)
            <mpfr-for-gcc-hidden>$(mpfr-for-gcc)
            <mpc-for-gcc-hidden>$(mpc-for-gcc)
            <isl-for-gcc-hidden>$(isl-for-gcc)
            <cloog-for-gcc-hidden>$(cloog-for-gcc)
            <lcov-hidden>$(lcov)
            <gcovr-hidden>$(gcovr)
            <gmp-hidden>$(gmp)
            <mpfr-hidden>$(mpfr)
            <mpc-hidden>$(mpc)
            <isl-hidden>$(isl)
            <cloog-hidden>$(cloog)
            <ppl-hidden>$(ppl)
            <icu4c-hidden>$(icu4c)
            <openmpi-hidden>$(openmpi)
            <mpi-backend-hidden>$(mpi-backend)
            <boost-hidden>$(boost)
            <clang-hidden>$(clang)
            <valgrind-hidden>$(valgrind)
          ;
      }
    }
  }
  else if [ is-clang "$(enabled-compiler)" ] {
    alias $(enabled-compiler)
      : gcc//install
        clang//install
        $(srcs)
        openmpi//install/<mpi-backend>$(mpi-backend)/<openmpi>$(OPENMPI)
      : <compiler-hidden>$(enabled-compiler)
        <multitarget-hidden>$(multitarget)
        <binutils-hidden>$(binutils)
        <gmp-for-gcc-hidden>$(gmp-for-gcc)
        <mpfr-for-gcc-hidden>$(mpfr-for-gcc)
        <mpc-for-gcc-hidden>$(mpc-for-gcc)
        <isl-for-gcc-hidden>$(isl-for-gcc)
        <cloog-for-gcc-hidden>$(cloog-for-gcc)
        <lcov-hidden>$(lcov)
        <gcovr-hidden>$(gcovr)
        <gmp-hidden>$(gmp)
        <mpfr-hidden>$(mpfr)
        <mpc-hidden>$(mpc)
        <isl-hidden>$(isl)
        <cloog-hidden>$(cloog)
        <ppl-hidden>$(ppl)
        <icu4c-hidden>$(icu4c)
        <openmpi-hidden>$(openmpi)
        <mpi-backend-hidden>$(mpi-backend)
        <boost-hidden>$(boost)
        <valgrind-hidden>$(valgrind)
      ;
  }
  else if [ is-icc "$(enabled-compiler)" ] {
    if "$(clang)" {
      srcs += "clang//install" ;
    }

    alias $(enabled-compiler)
      : gcc//install
        icc//install
        $(srcs)
      : <compiler-hidden>$(enabled-compiler)
        <multitarget-hidden>$(multitarget)
        <binutils-hidden>$(binutils)
        <gmp-for-gcc-hidden>$(gmp-for-gcc)
        <mpfr-for-gcc-hidden>$(mpfr-for-gcc)
        <mpc-for-gcc-hidden>$(mpc-for-gcc)
        <isl-for-gcc-hidden>$(isl-for-gcc)
        <cloog-for-gcc-hidden>$(cloog-for-gcc)
        <lcov-hidden>$(lcov)
        <gcovr-hidden>$(gcovr)
        <gmp-hidden>$(gmp)
        <mpfr-hidden>$(mpfr)
        <mpc-hidden>$(mpc)
        <isl-hidden>$(isl)
        <cloog-hidden>$(cloog)
        <ppl-hidden>$(ppl)
        <icu4c-hidden>$(icu4c)
        <openmpi-hidden>$(openmpi)
        <mpi-backend-hidden>$(mpi-backend)
        <boost-hidden>$(boost)
        <clang-hidden>$(clang)
        <valgrind-hidden>$(valgrind)
      ;
  }
  else {
    errors.error "an internal error." ;
  }
}
