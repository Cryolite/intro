project mingw-w64-headers ;

import alias ;
import errors ;
import feature ;
import make ;
import regex ;


make download : : @download-mingw-w64 ;
explicit download ;

rule download-mingw-w64 ( targets * : sources * : properties * )
{
  URL on $(targets) = http://downloads.sourceforge.net/project/mingw-w64/mingw-w64/mingw-w64-snapshot/mingw-w64-v1.0-snapshot-20101003.tar.bz2 ;
  TARBALL on $(targets) = $(INTRO_ROOT_DIR)/mingw-w64-v1.0-snapshot-20101003.tar.bz2 ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions download-mingw-w64
{
  rm -f "$(<)" || exit $?
  if [ ! -f "$(TARBALL)" ]; then
    ( cd "$(TARBALL:D)" && wget --quiet -- '$(URL)' ) \
      || { echo "ERROR: failed to download the MinGW-w64 tarball." 2>>"$(STDOUT_)" 1>&2; exit 1; }
    [ -f "$(TARBALL)" ] || exit 1
  fi
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


make expand : download : @expand-mingw-w64 ;
explicit expand ;

rule expand-mingw-w64 ( targets * : sources * : properties * )
{
  if ! $(sources[1]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  if $(sources[2]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  TARBALL on $(targets) = $(INTRO_ROOT_DIR)/mingw-w64-v1.0-snapshot-20101003.tar.bz2 ;
  DEST_DIR on $(targets) = $(INTRO_ROOT_DIR)/mingw-w64-v1.0-20101003 ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions expand-mingw-w64
{
  rm -f "$(<)" || exit $?
  [ -f "$(>[1])" ] || exit 1
  [ -f "$(TARBALL)" ] || exit 1
  if [ ! -x "$(DEST_DIR)/mingw-w64-headers/configure" ]; then
    rm -rf "$(DEST_DIR)" || exit $?
    tar xjf "$(TARBALL)" -C "$(TARBALL:D)" \
      || { echo "ERROR: failed to expand the tarball for the MinGW-w64 build." 2>>"$(STDERR_)" 1>&2; exit 1; }
    [ -x "$(DEST_DIR)/mingw-w64-headers/configure" ] || exit 1
  fi
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


make make
  : expand/<intro-stage>unspecified/<intro-host>unspecified
  : @make-mingw-w64-headers
  ;
explicit make ;

rule make-mingw-w64-headers ( targets * : sources * : properties * )
{
  OPTIONS on $(targets) = ;

  # Set the path to the 'configure' file.
  local configure = $(INTRO_ROOT_DIR)/mingw-w64-v1.0-20101003/mingw-w64-headers/configure ;
  CONFIGURE on $(targets) = $(configure) ;

  # Set the '--build' and '--host' options for the 'configure' script.
  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  local build = [ SHELL "\"$(INTRO_ROOT_DIR)/gcc/config.guess\" | tr --delete '\n'" ] ;
  if $(stage) = 1 {
    errors.error "ERROR: internal error." ;
  }
  else if $(stage) = 2 {
    OPTIONS on $(targets) += --build=$(build) ;
    OPTIONS on $(targets) += --host=$(HOST) ;
  }
  else {
    OPTIONS on $(targets) += --build=$(HOST) ;
    OPTIONS on $(targets) += --host=$(HOST) ;
  }

  # Set the 'prefix' option for the 'configure' script.
  local prefix = [ feature.get-values <intro-prefix> : $(properties) ] ;
  OPTIONS on $(targets) += --prefix=\"$(PREFIX)\" ;
}
actions make-mingw-w64-headers
{
  rm -f "$(<)" || exit $?
  [ -x "$(CONFIGURE)" ] || exit 1
  { mkdir -p "$(<:D)/build" && ( cd "$(<:D)/build" && rm -rf * ); } || exit $?
  $(SET_RUN_VARS)
  ( cd "$(<:D)/build" && "$(CONFIGURE)" $(OPTIONS) 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    echo "ERROR: failed to 'configure' for the mingw-w64-headers build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  [ -f "$(<:D)/build/Makefile" ] || exit 1
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    echo "ERROR: failed to 'make' for the mingw-w64-headers build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  ( cd "$(<:D)/build" && make --jobs=$(CONCURRENCY) install 1>>"$(STDOUT_)" 2>>"$(STDERR_)" )
  if [ $? -ne 0 ]; then
    $(UNSET_RUN_VARS)
    echo "ERROR: failed to 'make install' for the mingw-w64-headers build." 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  if [ $(HOST) = x86_64-w64-mingw32 ]; then
    mkdir -p "$(PREFIX)/$(HOST)/lib" || exit $?
    ln -sf "$(PREFIX)/$(HOST)/lib" "$(PREFIX)/$(HOST)/lib64" || exit $?
  fi
  $(UNSET_RUN_VARS)
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


rule install-req ( properties * )
{
  local result = <source>make ;

  local stage = [ feature.get-values <intro-stage> : $(properties) ] ;
  if $(stage) = 1 {
    errors.error "ERROR: '<intro-stage>1' is not valid for the mingw-w64-headers build." ;
  }

  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  if $(host) = unspecified {
    errors.error "ERROR: '<intro-host>' is not specified for the mingw-w64-headers build." ;
  }

  local link = [ feature.get-values <intro-link> : $(properties) ] ;
  if $(link) != unspecified {
    errors.error "ERROR: '<intro-link>$(link)' is not valid for the mingw-w64-headers build." ;
  }

  local multilib = [ feature.get-values <intro-multilib> : $(properties) ] ;
  if $(multilib) != unspecified {
    errors.error "ERROR: '<intro-multilib>$(multilib)' is not valid for the mingw-w64-headers build." ;
  }

  local version ;
  version = [ feature.get-values <binutils-version> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<binutils-version>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <binutils-version-hidden> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<binutils-version-hidden>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <gmp-version> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<gmp-version>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <gmp-version-hidden> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<gmp-version-hidden>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <mpfr-version> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<mpfr-version>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <mpfr-version-hidden> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<mpfr-version-hidden>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <mpc-version> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<mpc-version>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <mpc-version-hidden> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<mpc-version-hidden>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  version = [ feature.get-values <gcc-version> : $(properties) ] ;
  if $(version) != unspecified {
    errors.error "ERROR: '<gcc-version>$(version)' is not valid for the mingw-w64-headers build." ;
  }
  local gcc-default = [ feature.get-values <gcc-default> : $(properties) ] ;
  if $(gcc-default) != unspecified {
    errors.error "ERROR: '<gcc-default>$(gcc-default)' is not valid for the mingw-w64-headers build." ;
  }

  return $(result) ;
}

alias install : : <conditional>@install-req ;
explicit install ;
