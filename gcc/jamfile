project intro/gcc ;

import alias ;
import errors ;
import feature ;
import make ;
import path ;
import regex ;
import "$(INTRO_ROOT_DIR)/compilers"
  : get-libdir
  ;


rule assert-specified ( feature : properties * )
{
  local val = [ feature.get-values $(feature) : $(properties) ] ;
  if $(val) = unspecified {
    errors.error $(feature) is not specified for GCC build. ;
  }
}

rule assert-unspecified ( feature : properties * )
{
  local val = [ feature.get-values $(feature) : $(properties) ] ;
  if $(val) != unspecified {
    errors.error $(feature) is not valid for GCC build. ;
  }
}



for local version in [ "$(INTRO_ROOT_DIR)/compilers.get-gcc-versions" $(COMPILERS) ]
{
  make "$(INTRO_ROOT_DIR)/gcc-$(version).tar.bz2" : : @download ;
  explicit "$(INTRO_ROOT_DIR)/gcc-$(version).tar.bz2" ;
}

rule download ( targets * : sources * : properties * )
{
  if $(sources[1])
  {
    errors.error "a wrong number of sources." ;
  }
  assert-unspecified <triplet>            : $(properties) ;
  assert-unspecified <multitarget>        : $(properties) ;
  assert-unspecified <multitarget-hidden> : $(properties) ;
  assert-unspecified <compiler>           : $(properties) ;
  assert-specified   <compiler-hidden>    : $(properties) ;

  local compiler = [ feature.get-values <compiler-hidden> : $(properties) ] ;
  if ! [ "$(INTRO_ROOT_DIR)/compilers.is-gcc" "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local version = [ "$(INTRO_ROOT_DIR)/compilers.get-version" $(compiler) ] ;
  VERSION on $(targets) = $(version) ;
  local url_prefix = "http://ftp.dti.ad.jp/pub/lang/gcc" ;          # Japan ++
  #local url_prefix = "http://ftp.tsukuba.wide.ad.jp/software/gcc" ; # Japan +++
  if [ "$(INTRO_ROOT_DIR)/compilers.is-gcc-release" $(compiler) ]
  {
    URL on $(targets) = "$(url_prefix)/releases/gcc-$(version)/gcc-$(version).tar.bz2" ;
  }
  else if [ "$(INTRO_ROOT_DIR)/compilers.is-gcc-snapshot" $(compiler) ]
  {
    URL on $(targets) = "$(url_prefix)/snapshots/$(version)/gcc-$(version).tar.bz2" ;
  }
  else {
    errors.error "an internal error." ;
  }
}
actions download
{
  rm -rf "$(<)" || exit $?
  if [ -n "$(STREAM)" ]; then
    ( cd "$(<:D)" && wget -- '$(URL)' >> "$(STREAM)" 2>&1 )
  else
    ( cd "$(<:D)" && wget --quiet -- '$(URL)' )
  fi
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to download GCC $(VERSION) tarball." 1>&2
    echo -n "ERROR: failed to download GCC $(VERSION) tarball." | $(AWACS)
    rm -rf "$(<)"
    exit 1
  fi
  [ -f "$(<)" ] || exit 1
  exit 0
}



for local version in [ "$(INTRO_ROOT_DIR)/compilers.get-gcc-versions" $(COMPILERS) ]
{
  # Use `README' file as a target representing the completion of
  # decompression action. It is suitable for the purpose because of the
  # following reasons;
  #
  #   - The name of this file is considered stable even if the version
  #     changes.
  #   - This file won't be modified during the build procedure.
  #
  make "$(INTRO_ROOT_DIR)/gcc-$(version)/README"
    : "$(INTRO_ROOT_DIR)/gcc-$(version).tar.bz2"
    : @expand
    ;
  explicit "$(INTRO_ROOT_DIR)/gcc-$(version)/README" ;
}

rule expand ( targets * : sources * : properties * )
{
  if ! $(sources[1])
  {
    errors.error "an internal error." ;
  }
  if $(sources[2])
  {
    errors.error "an internal error." ;
  }
  assert-unspecified <triplet>            : $(properties) ;
  assert-unspecified <multitarget>        : $(properties) ;
  assert-unspecified <multitarget-hidden> : $(properties) ;
  assert-unspecified <compiler>           : $(properties) ;
  assert-specified   <compiler-hidden>    : $(properties) ;

  local compiler = [ feature.get-values <compiler-hidden> : $(properties) ] ;
  if ! [ "$(INTRO_ROOT_DIR)/compilers.is-gcc" "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local version = [ "$(INTRO_ROOT_DIR)/compilers.get-version" $(compiler) ] ;
  VERSION on $(targets) = $(version) ;
}
actions expand
{
  rm -rf "$(<:D)" || exit 1
  [ -f "$(>)" ] || exit 1
  if [ -n "$(STREAM)" ]; then
    tar xjvf "$(>)" --directory="$(INTRO_ROOT_DIR)" >> "$(STREAM)" 2>&1
  else
    tar xjf "$(>)" --directory="$(INTRO_ROOT_DIR)"
  fi
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to expand GCC $(VERSION) tarball." 1>&2
    echo -n "ERROR: failed to expand GCC $(VERSION) tarball." | $(AWACS)
    rm -rf "$(<:D)"
    exit 1
  fi
  # If the timestamp of the tarball's contents is restored, the modification
  # time of the source directory could be older than the one of the tarball.
  # Such behavior is not desirable because the decompression always happens.
  # Therefore, `touch' is required.
  touch --no-create "$(<)"
  [ -f "$(<)" ] || exit 1
  exit 0
}



rule srcdir-req ( properties * )
{
  assert-unspecified <triplet>            : $(properties) ;
  assert-unspecified <multitarget>        : $(properties) ;
  assert-unspecified <multitarget-hidden> : $(properties) ;
  assert-specified   <compiler>           : $(properties) ;
  assert-unspecified <compiler-hidden>    : $(properties) ;

  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  if ! [ "$(INTRO_ROOT_DIR)/compilers.is-gcc" "$(compiler)" ]
  {
    errors.error "an internal error." ;
  }
  local version = [ "$(INTRO_ROOT_DIR)/compilers.get-version" $(compiler) ] ;
  return <source>"$(INTRO_ROOT_DIR)/gcc-$(version)/README/<compiler>unspecified/<compiler-hidden>$(compiler)/$(DEFAULT_PROPERTIES)" ;
}

alias srcdir : : <conditional>@srcdir-req ;
explicit srcdir ;



for local compiler in $(COMPILERS)
{
  local srcdirs ;
  if $(BINUTILS)
  {
    srcdirs += ../binutils//srcdir/<triplet>unspecified/<multitarget>unspecified/<binutils-hidden>$(BINUTILS)/<compiler>unspecified/<variant>debug ;
  }
  if $(GMP_FOR_GCC)
  {
    srcdirs += ../gmp//srcdir/<triplet>unspecified/<multitarget>unspecified/<gmp-hidden>$(GMP_FOR_GCC)/<compiler>unspecified/<variant>debug ;
  }
  if $(MPFR_FOR_GCC)
  {
    srcdirs += ../mpfr//srcdir/<triplet>unspecified/<multitarget>unspecified/<mpfr-hidden>$(MPFR_FOR_GCC)/<compiler>unspecified/<variant>debug ;
  }
  if $(MPC_FOR_GCC)
  {
    srcdirs += ../mpc//srcdir/<triplet>unspecified/<multitarget>unspecified/<mpc-hidden>$(MPC_FOR_GCC)/<compiler>unspecified/<variant>debug ;
  }
  if $(PPL_FOR_GCC)
  {
    srcdirs += ../ppl//srcdir/<triplet>unspecified/<multitarget>unspecified/<ppl-hidden>$(PPL_FOR_GCC)/<compiler>unspecified/<variant>debug ;
  }
  if $(ISL_FOR_GCC)
  {
    srcdirs += ../isl//srcdir/<triplet>unspecified/<multitarget>unspecified/<isl-hidden>$(ISL_FOR_GCC)/<compiler>unspecified/<variant>debug ;
  }
  if $(CLOOG_FOR_GCC)
  {
    srcdirs += ../cloog//srcdir/<triplet>unspecified/<multitarget>unspecified/<cloog-hidden>$(CLOOG_FOR_GCC)/<compiler>unspecified/<variant>debug ;
  }
  local prefix-leaf = [ "$(INTRO_ROOT_DIR)/compilers.get-prefix-leaf" "$(compiler)" : "$(GCC_FOR_CLANG)" ] ;
  local compiler-prefix = "$(PREFIX)/$(prefix-leaf)" ;
  if [ "$(INTRO_ROOT_DIR)/compilers.is-gcc" $(compiler) ]
  {
    make "$(compiler-prefix)/bin/g++-wrapper"
      : $(srcdirs)
        srcdir/<triplet>unspecified/<multitarget>unspecified/<variant>debug
      : @make-install
      ;
  }
  else if [ "$(INTRO_ROOT_DIR)/compilers.is-clang" $(compiler) ]
  {
    if ! $(GCC_FOR_CLANG)
    {
      errors.error "an internal error." ;
    }
    make "$(compiler-prefix)/bin/g++-wrapper"
      : $(srcdirs)
        srcdir/<triplet>unspecified/<multitarget>unspecified/<compiler>$(GCC_FOR_CLANG)/<variant>debug
      : @make-install
      ;
  }
  else
  {
    errors.error "an internal error." ;
  }
  explicit "$(compiler-prefix)/bin/g++-wrapper" ;
}

rule make-install ( targets * : sources * : properties * )
{
  assert-specified   <triplet>            : $(properties) ;
  assert-specified   <multitarget>        : $(properties) ;
  assert-unspecified <multitarget-hidden> : $(properties) ;
  assert-specified   <compiler>           : $(properties) ;
  assert-unspecified <compiler-hidden>    : $(properties) ;

  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local version ;
  local compiler-description ;
  if [ "$(INTRO_ROOT_DIR)/compilers.is-gcc" $(compiler) ]
  {
    version = [ "$(INTRO_ROOT_DIR)/compilers.get-version" $(compiler) ] ;
    compiler-description = [ "$(INTRO_ROOT_DIR)/compilers.get-compiler-description" $(compiler) ] ;
  }
  else if [ "$(INTRO_ROOT_DIR)/compilers.is-clang" $(compiler) ]
  {
    version = [ "$(INTRO_ROOT_DIR)/compilers.get-version" $(GCC_FOR_CLANG) ] ;
    compiler-description = [ "$(INTRO_ROOT_DIR)/compilers.get-compiler-description" $(GCC_FOR_CLANG) ] ;
  }
  else
  {
    errors.error "an internal error." ;
  }
  COMPILER_DESCRIPTION on $(targets) = "$(compiler-description)" ;

  local srcdir = "$(INTRO_ROOT_DIR)/gcc-$(version)" ;
  SRCDIR on $(targets) = "$(srcdir)" ;

  local objdir = "$(INTRO_ROOT_DIR)/objdir" ;
  OBJDIR on $(targets) = "$(objdir)" ;

  OPTIONS on $(targets) = ;

  # Set the compiler-specific prefix.
  local prefix-leaf = [ "$(INTRO_ROOT_DIR)/compilers.get-prefix-leaf" $(compiler) : $(GCC_FOR_CLANG) ] ;
  local compiler-prefix = "$(PREFIX)/$(prefix-leaf)" ;
  COMPILER_PREFIX on $(targets) = "$(compiler-prefix)" ;

  # Set the '--prefix' option for the 'configure' script.
  OPTIONS on $(targets) += "--prefix='$(compiler-prefix)'" ;

  local libdir = [ get-libdir "$(PREFIX)" : $(properties) : $(GCC_FOR_CLANG) ] ;
  local libdir-native = [ path.native "$(libdir)" ] ;
  LIBDIR on $(targets) = "$(libdir-native)" ;
  OPTIONS on $(targets) += "--libdir='$(libdir-native)'" ;

  local triplet = [ feature.get-values <triplet> : $(properties) ] ;
  TRIPLET on $(targets) = $(triplet) ;

  # Set the '--build', '--host' and '--target' options for the 'configure' script.
  OPTIONS on $(targets) += --build=$(triplet) ;
  OPTIONS on $(targets) += --host=$(triplet) ;
  OPTIONS on $(targets) += --target=$(triplet) ;

  # Set the build variants of runtime libraries.
  OPTIONS on $(targets) += --enable-shared ;
  OPTIONS on $(targets) += --enable-static ;

  # Set the linker configuration to be used by the installed GCC front-end.
  #
  # gold linker has a bug that ignores `LD_RUN_PATH' environment variable.
  # http://sourceware.org/bugzilla/show_bug.cgi?id=13764
  # If the day comes when this bug is fixed, gold can become the default
  # linker.
  OPTIONS on $(targets) += --enable-ld=default ;
  OPTIONS on $(targets) += --enable-gold ;

  local multitarget = [ feature.get-values <multitarget> : $(properties) ] ;
  MULTITARGET on $(targets) = $(multitarget) ;

  if $(triplet) = x86_64-unknown-linux-gnu && $(multitarget) = yes
  {
    OPTIONS on $(targets) += --enable-multilib ;
  }
  else if $(triplet) = x86_64-w64-mingw32 && $(multitarget) = yes
  {
    OPTIONS on $(targets) += --enable-multilib ;
  }
  else
  {
    OPTIONS on $(targets) += --disable-multilib ;
  }

  if $(triplet) = i686-w64-mingw32 || $(triplet) = x86_64-w64-mingw32
  {
    OPTIONS on $(targets) += --enable-threads=win32 ;
  }
  else
  {
    OPTIONS on $(targets) += --enable-threads=posix ;
  }

  OPTIONS on $(targets) += --enable-tls ;

  if $(triplet) = i686-pc-linux-gnu || $(triplet) = i686-pc-cygwin || $(triplet) = i686-w64-mingw32
  {
    OPTIONS on $(targets) += --with-arch=i686 ;
    OPTIONS on $(targets) += --with-tune=generic ;
  }
  else if $(triplet) = x86_64-unknown-linux-gnu || $(triplet) = x86_64-w64-mingw32
  {
    OPTIONS on $(targets) += --with-arch-32=i686 ;
    OPTIONS on $(targets) += --with-tune=generic ;
  }

  if $(triplet) = i686-pc-cygwin
  {
    # Follow what the built-in GCC does.
    OPTIONS on $(targets) += --disable-__cxa_atexit ;
  }

  if $(PPL_FOR_GCC) && $(CLOOG_FOR_GCC)
  {
    # This option is a workaround required to build PPL and CLooG alongside
    # during GCC bootstrap.
    OPTIONS on $(targets) += --enable-build-with-cxx ;
  }

  # Required explicitly by `--enable-gold' on GCC 4.6.
  # Required by GCC 4.7?
  OPTIONS on $(targets) += --enable-build-with-cxx ;

  OPTIONS on $(targets) += --enable-bootstrap ;

  OPTIONS on $(targets) += --enable-languages=c,c++ ;

  OPTIONS on $(targets) += --enable-libssp ;

  OPTIONS on $(targets) += --enable-libquadmath ;

  if $(triplet) = i686-w64-mingw32 || $(triplet) = x86_64-w64-mingw32
  {
    # The target is `*-w64-mingw32.'
    # `--enable-libgomp' option requires `pthreads-w32' on the target.
    # Currently, just disable this option.
    OPTIONS on $(targets) += --disable-libgomp ;
  }
  else
  {
    OPTIONS on $(targets) += --enable-libgomp ;
  }

  if $(triplet) = i686-pc-cygwin || $(triplet) = i686-w64-mingw32
  {
    OPTIONS on $(targets) += --with-dwarf2 ;
    OPTIONS on $(targets) += --disable-sjlj-exceptions ;
  }
  # `--with-dwarf2' is not supported on `x86_64-w64-mingw32' targets.

  if $(triplet) = x86_64-unknown-linux-gnu && $(multitarget) = yes
  {
    OPTIONS on $(targets) += --enable-targets=x86_64-unknown-linux-gnu,i686-pc-linux-gnu ;
  }
  else if $(triplet) = x86_64-w64-mingw32 && $(multitarget) = yes
  {
    OPTIONS on $(targets) += --enable-targets=x86_64-w64-mingw32,i686-w64-mingw32 ;
  }

  if $(triplet) = i686-w64-mingw32 || $(triplet) = x86_64-w64-mingw32
  {
    OPTIONS on $(targets) += --disable-win32-registry ;
  }

  #OPTIONS on $(targets) += --enable-checking=all ;

  OPTIONS on $(targets) += --disable-nls ;

  if $(triplet) = i686-pc-cygwin
  {
    # Follow what the built-in GCC does.
    OPTIONS on $(targets) += --enable-graphite ;
  }

  if $(PPL_FOR_GCC) && $(CLOOG_FOR_GCC)
  {
    # Options required to build PPL and CLooG alongside during GCC bootstrap.
    OPTIONS on $(targets) += --enable-cloog-backend=isl ;
    OPTIONS on $(targets) += --with-stage1-ldflags=-lstdc++ ;
  }
  else if $(ISL_FOR_GCC) && $(CLOOG_FOR_GCC)
  {
    # Options required to build CLooG alongside during GCC bootstrap.
    OPTIONS on $(targets) += --enable-cloog-backend=isl ;
  }

  OPTIONS on $(targets) += --enable-linker-build-id ;

  OPTIONS on $(targets) += --enable-lto ;

  OPTIONS on $(targets) += --enable-plugins ;

  OPTIONS on $(targets) += --with-system-zlib ;

  OPTIONS on $(targets) += --enable-libstdcxx-time=yes ;

  OPTIONS on $(targets) += --enable-libstdcxx-debug ;

  #OPTIONS on $(targets) += --enable-concept-checks ;

  if $(PPL_FOR_GCC) && $(CLOOG_FOR_GCC)
  {
    INSTALL_SCRIPT on $(targets) = "$(INTRO_ROOT_DIR)/gcc/install-4.6.sh" ;
  }
  else if $(ISL_FOR_GCC) && $(CLOOG_FOR_GCC)
  {
    INSTALL_SCRIPT on $(targets) = "$(INTRO_ROOT_DIR)/gcc/install-4.8.sh" ;
  }
  else
  {
    INSTALL_SCRIPT on $(targets) = "$(INTRO_ROOT_DIR)/gcc/install-4.8.sh" ;
  }
}
actions make-install
{
  # Clean up the `OBJDIR'.
  { mkdir -p '$(OBJDIR)' && ( cd '$(OBJDIR)' && rm -rf * ); } || exit 1

  '$(INSTALL_SCRIPT)' '$(INTRO_ROOT_DIR)'       \
                      $(TRIPLET)                \
                      $(MULTITARGET)            \
                      '$(BINUTILS)'             \
                      '$(GMP_FOR_GCC)'          \
                      '$(MPFR_FOR_GCC)'         \
                      '$(MPC_FOR_GCC)'          \
                      '$(ISL_FOR_GCC)'          \
                      '$(CLOOG_FOR_GCC)'        \
                      $(CONCURRENCY)            \
                      '$(AWACS)'                \
                      '$(STREAM)'               \
                      '$(SRCDIR)'               \
                      '$(OBJDIR)'               \
                      '$(COMPILER_PREFIX)'      \
                      '$(COMPILER_DESCRIPTION)' \
                      '$(LIBDIR)'               \
                      $(OPTIONS)
  if [ $? -ne 0 ]; then
    exit 1
  fi

  # Check the creation of `g++-wrapper'.
  [ -x '$(<)' ] || exit 1

  # Clean up the OBJDIR.
  rm -rf '$(OBJDIR)' || exit 1

  echo -n '$(COMPILER_DESCRIPTION) ($(TRIPLET)) was successfully built.' | $(AWACS)
  echo -n 'NOTE: Binutils $(BINUTILS), GMP $(GMP_FOR_GCC), MPFR $(MPFR_FOR_GCC), MPC $(MPC_FOR_GCC), PPL $(PPL_FOR_GCC), CLooG $(CLOOG_FOR_GCC) were bootstrapped alongside.' | $(AWACS)
  exit 0
}



rule install-req ( properties * )
{
  assert-specified   <triplet>            : $(properties) ;
  assert-specified   <multitarget>        : $(properties) ;
  assert-unspecified <multitarget-hidden> : $(properties) ;
  assert-specified   <compiler>           : $(properties) ;
  assert-unspecified <compiler-hidden>    : $(properties) ;

  local compiler = [ feature.get-values <compiler> : $(properties) ] ;
  local prefix-leaf = [ "$(INTRO_ROOT_DIR)/compilers.get-prefix-leaf" $(compiler) : $(GCC_FOR_CLANG) ] ;
  local compiler-prefix = "$(PREFIX)/$(prefix-leaf)" ;
  return <source>"$(compiler-prefix)/bin/g++-wrapper/<std>c++03/<variant>release/<ssp>off/<mudflap>off/<address-sanitizer>off/<libstdc++-debug-mode>off" ;
}

alias install : : <conditional>@install-req ;
explicit install ;
