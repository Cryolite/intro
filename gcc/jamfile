project gcc ;

import alias ;
import errors ;
import feature ;
import make ;
import path ;
import regex ;


rule binutils-dep-req ( properties * )
{
  local result = ;
  local build = [ feature.get-values <intro-build> : $(properties) ] ;
  local target = [ feature.get-values <intro-target> : $(properties) ] ;
  if $(target) != $(build) {
    result = <source>../binutils//install ;
    results = $(results)/<intro-build>unspecified ;
    # `<intro-host>' is automatically propagated.
    # `<intro-target>' is automatically propagated.
    # `<intro-abi>' is automatically propagated.
    # `<intro-prefix>' is automatically propagated.
    # `<intro-link>' is automatically propagated.
    # `<intro-check>' is automatically propagated.
    # `<intro-stdout>' is automatically propagated.
    # `<intro-stderr>' is automatically propagated.
    result = $(result)/<gmp-version>unspecified ;
    result = $(result)/<mpfr-version>unspecified ;
    result = $(result)/<mpc-version>unspecified ;
    result = $(result)/<gcc-version>unspecified ;
  }
  return $(result) ;
}

alias binutils-dep
  : # The source `../binutils//install' might be introduced by the conditional requirements.
  : <conditional>@binutils-dep-req
  ;
explicit binutils-dep ;


rule mpc-dep-req ( properties * )
{
  local result = <source>../mpc//install ;
  results = $(results)/<intro-build>unspecified ;
  local build = [ feature.get-values <intro-build> : $(properties) ] ;
  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  if $(host) = $(build) {
    result = $(result)/<intro-host>unspecified ;
  }
  else {
    result = $(result)/<intro-host>$(host) ;
  }
  result = $(result)/<intro-target>unspecified ;
  # `<intro-abi>' is automatically propagated.
  local prefix = [ feature.get-values <intro-prefix> : $(properties) ] ;
  if $(host) != $(build) {
    prefix = $(prefix)/$(host) ;
  }
  result = $(result)/<intro-prefix>$(prefix) ;
  if $(host) = x86_64-w64-mingw32 || $(host) = i686-w64-mingw32 {
    result = $(result)/<intro-link>static ;
  }
  else {
    result = $(result)/<intro-link>both ;
  }
  local check = [ feature.get-values <intro-check> : $(properties) ] ;
  if $(host) = $(build) {
    result = $(result)/<intro-check>yes ;
  }
  else {
    result = $(result)/<intro-check>$(check) ;
  }
  # `<intro-stdour>' is automatically propagated.
  # `<intro-stderr>' is automatically propagated.
  result = $(result)/<binutils-version>unspecified ;
  result = $(result)/<gcc-version>unspecified ;
  return $(result) ;
}

alias mpc-dep
  : # The source `../mpc//install' is introduced by the conditional requirements.
  : <conditional>@mpc-dep-req
  ;
explicit mpc-dep ;


rule mingw-w64-headers-dep-req ( properties * )
{
  local result = ;
  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  local target = [ feature.get-values <intro-target> : $(properties) ] ;
  if $(target) != $(host) {
    if $(target) = x86_64-w64-mingw32 || $(target) = i686-w64-mingw32 {
      result = <source>../mingw-w64-headers//install ;
      # `<intro-build>' is automatically propagated.
      # `<intro-host>' is automatically propagated.
      # `<intro-target>' is automatically propagated.
      # `<intro-abi>' is automatically propagated.
      # `<intro-prefix>' is automatically propagated.
      # `<intro-link>' is automatically propagated.
      # `<intro-check>' is automatically propagated.
      # `<intro-stdout>' is automatically propagated.
      # `<intro-stderr>' is automatically propagated.
      result = $(result)/<gmp-version>unspecified ;
      result = $(result)/<mpfr-version>unspecified ;
      result = $(result)/<mpc-version>unspecified ;
      result = $(result)/<binutils-version>unspecified ;
      result = $(result)/<gcc-version>unspecified ;
    }
  }
  return $(result) ;
}

alias mingw-w64-headers-dep
  : # The source `../mingw-w64-headers//install' might be introduced by the conditional requirements.
  : <conditional>@mingw-w64-headers-dep-req
  ;
explicit mingw-w64-headers-dep ;


make gcc.download
  : # No sources.
  : @download-gcc
  ;
explicit gcc.download ;

rule download-gcc ( targets * : sources * : properties * )
{
  local version = [ feature.get-values <gcc-version> : $(properties) ] ;
  URL on $(targets) = http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-$(version)/gcc-$(version).tar.bz2 ;
  TARBALL_GZ on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.gz ;
  TARBALL_BZ2 on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.bz2 ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions download-gcc
{
  rm -f "$(<)" || exit $?
  if [ ! -f "$(TARBALL_GZ)" -a ! -f "$(TARBALL_BZ2)" ]; then
    ( cd "$(TARBALL_BZ2:D)" && wget --quiet --timestamping -- '$(URL)' ) \
      || { echo "ERROR: failed to download the GCC tarball." 2>>"$(STDOUT_)" 1>&2; exit 1; }
    [ ! -f "$(TARBALL_BZ2)" ] && exit 1
  fi
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


make gcc.expand
  : gcc.download
  : @expand-gcc
  ;
explicit gcc.expand ;

rule expand-gcc ( targets * : sources * : properties * )
{
  if ! $(sources[1]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  if $(sources[2]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  local version = [ feature.get-values <gcc-version> : $(properties) ] ;
  TARBALL_GZ on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.gz ;
  TARBALL_BZ2 on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version).tar.bz2 ;
  DEST_DIR on $(targets) = $(INTRO_ROOT_DIR)/gcc-$(version) ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions expand-gcc
{
  rm -f "$(<)" || exit $?
  [ ! -f "$(>[1])" ] && exit 1
  if [ ! -f "$(DEST_DIR)/configure" ]; then
    rm -rf "$(DEST_DIR)" || exit $?
    if [ -f "$(TARBALL_GZ)" ]; then
      tar xzf "$(TARBALL_GZ)" -C "$(TARBALL_GZ:D)" \
        || { echo "ERROR: failed to expand the tarball for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
    elif [ -f "$(TARBALL_BZ2)" ]; then
      tar xjf "$(TARBALL_BZ2)" -C "$(TARBALL_BZ2:D)" \
        || { echo "ERROR: failed to expand the tarball for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
    else
      exit 1
    fi
    [ ! -f "$(DEST_DIR)/configure" ] && exit 1
  fi
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


make gcc.configure
  : binutils-dep
    mpc-dep
    mingw-w64-headers-dep
    gcc.expand/<intro-host>unspecified/<intro-target>unspecified/<gmp-version>unspecified/<mpfr-version>unspecified/<mpc-version>unspecified/<binutils-version>unspecified
  : @configure-gcc
  ;
explicit gcc.configure ;

rule configure-gcc ( targets * : sources * : properties * )
{
  OPTIONS on $(targets) = ;

  local version = [ feature.get-values <gcc-version> : $(properties) ] ;

  # Set the path to the 'configure' file.
  local configure = $(INTRO_ROOT_DIR)/gcc-$(version)/configure ;
  CONFIGURE on $(targets) = $(configure) ;

  # Set the 'build' option for the 'configure' script.
  local build = [ feature.get-values <intro-build> : $(properties) ] ;
  OPTIONS on $(targets) += --build=$(build) ;

  # Set the 'host' option for the 'configure' script.
  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  OPTIONS on $(targets) += --host=$(host) ;

  # Set the 'target' option for the 'configure' script.
  local target = [ feature.get-values <intro-target> : $(properties) ] ;
  TARGET on $(targets) = $(target) ;
  OPTIONS on $(targets) += --target=$(target) ;

  local mingw32-target = 0 ;
  local mingw32-host-cross = 0 ;
  if $(target) = x86_64-w64-mingw32 || $(target) = i686-w64-mingw32 {
    mingw32-target = 1 ;
    if $(host) != $(build) {
      mingw32-host-cross = 1 ;
    }
  }
  MINGW32_TARGET on $(targets) = $(mingw32-target) ;
  MINGW32_HOST_CROSS on $(targets) = $(mingw32-host-cross) ;

  # Set the 'prefix' option for the 'configure' script.
  local prefix = [ feature.get-values <intro-prefix> : $(properties) ] ;
  PREFIX on $(targets) = $(prefix) ;

  OPTIONS on $(targets) += --prefix=\"$(prefix)\" ;

  if $(target) != $(host) {
    OPTIONS on $(targets) += --program-prefix=$(target)- ;
  }

  local gcc-default = [ feature.get-values <gcc-default> : $(properties) ] ;
  if $(gcc-default) = no {
    OPTIONS on $(targets) += --program-suffix=-$(version) ;
  }

  OPTIONS on $(targets) += --enable-shared ;

  if [ regex.match "^(x86_64-)" : $(target) : 1 ] {
    OPTIONS on $(targets) += --enable-multilib ;
  }
  if $(target) = i686-w64-mingw32 {
    OPTIONS on $(targets) += --disable-multilib ;
  }

  OPTIONS on $(targets) += --enable-libstdcxx-debug ;

  OPTIONS on $(targets) += --enable-threads ;

  local check = [ feature.get-values <intro-check> : $(properties) ] ;
  if $(check) = unspecified {
    # Do nothing.
  }
  else if $(check) = no {
    OPTIONS on $(targets) += --disable-bootstrap ;
  }
  else {
    OPTIONS on $(targets) += --enable-bootstrap ;
  }

  if $(gcc-default) = no {
    OPTIONS on $(targets) += --enable-version-specific-runtime-libs ;
  }

  OPTIONS on $(targets) += --enable-languages=c,c++ ;

  if $(mingw32-target) != 1 {
    # This option requires `pthreads-w32' for `*-mingw32' targets.
    OPTIONS on $(targets) += --enable-libgomp ;
  }

  # dwarf2 is not supported on 64-bit MinGW-w64.
  # if $(mingw32-target) = 1 {
  #   OPTIONS on $(targets) += --with-dwarf2 ;
  # }

  if [ regex.match "^(x86_64-)" : $(target) : 1 ] {
    OPTIONS on $(targets) += --enable-targets=all ;
  }

  if $(host) = x86_64-w64-mingw32 || $(host) = i686-w64-mingw32 {
    OPTIONS on $(targets) += --disable-win32-registry ;
  }

  if $(host) = x86_64-w64-mingw32 || $(host) = i686-w64-mingw32 {
    OPTIONS on $(targets) += --disable-nls ;
  }

  # Set the 'with-gmp', 'with-mpfr' and 'with-mpc' options for the 'configure' script.
  if $(host) = $(build) {
    OPTIONS on $(targets) += --with-gmp=\"$(prefix)\" ;
    OPTIONS on $(targets) += --with-mpfr=\"$(prefix)\" ;
    OPTIONS on $(targets) += --with-mpc=\"$(prefix)\" ;
  }
  else {
    OPTIONS on $(targets) += --with-gmp=\"$(prefix)/$(host)\" ;
    OPTIONS on $(targets) += --with-mpfr=\"$(prefix)/$(host)\" ;
    OPTIONS on $(targets) += --with-mpc=\"$(prefix)/$(host)\" ;
  }

  # Set the '--with-sysroot' option for the 'configure' script.
  if $(target) != $(build) {
    OPTIONS on $(targets) += --with-sysroot=\"$(prefix)\" ;
  }

  # if $(mingw32-target) = 1 {
  #   OPTIONS on $(targets) += --disable-sjlj-exceptions ;
  # }

  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions configure-gcc
{
  rm -f "$(<)" || exit $?
  [ ! -f "$(CONFIGURE)" ] && exit 1
  ( mkdir -p "$(<:D)/build" && { cd "$(<:D)/build" && rm -rf *; } ) || exit $?
  [ $(MINGW32_TARGET) -ne 0 ] \
    && { ln -sf "$(PREFIX)/$(TARGET)" "$(PREFIX)/mingw" || exit $?; }
  [ $(MINGW32_HOST_CROSS) -ne 0 ] \
    && { ( mkdir -p "$(CONFIGURE:D)/winsup/mingw" && cd "$(CONFIGURE:D)/winsup/mingw" && ln -sf "$(PREFIX)/$(TARGET)/include" include ) || exit $?; }
  ( cd "$(<:D)/build" && "$(CONFIGURE)" $(OPTIONS) 1>>"$(STDOUT_)" 2>>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'configure' for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
  [ $(MINGW32_TARGET) -ne 0 ] && { rm "$(PREFIX)/mingw" || exit $?; }
  [ ! -f "$(<:D)/build/Makefile" ] && exit 1
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


make gcc-mingw32-cross-stage1.make
  : gcc.configure
  : @make-gcc-mingw32-cross-stage1
  ;
explicit gcc-mingw32-cross-stage1.make ;

rule make-gcc-mingw32-cross-stage1 ( targets * : sources * : properties * )
{
  if ! $(sources[1]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  if $(sources[2]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  PREFIX on $(targets) = [ feature.get-values <intro-prefix> : $(properties) ] ;
  TARGET on $(targets) = [ feature.get-values <intro-target> : $(properties) ] ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions make-gcc-mingw32-cross-stage1
{
  rm -f "$(<)" || exit $?
  [ ! -f "$(>[1])" ] && exit 1
  [ ! -f "$(>[1]:D)/build/Makefile" ] && exit 1
  ln -sf "$(PREFIX)/$(TARGET)" "$(PREFIX)/mingw" || exit $?
  ( cd "$(<:D)/build" && make all-gcc 1>>"$(STDOUT_)" 2>>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'make all-gcc' for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
  ( cd "$(<:D)/build" && make install-gcc 1>>"$(STDOUT_)" 2>>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'make install-gcc' for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
  rm "$(PREFIX)/mingw" || exit $?
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


rule make-gcc-req ( properties * )
{
  local result = ;
  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  local target = [ feature.get-values <intro-target> : $(properties) ] ;
  if $(target) = x86_64-w64-mingw32 || $(target) = i686-w64-mingw32 {
    result = <source>../mingw-w64-crt//install ;
    local check = [ feature.get-values <intro-check> : $(properties) ] ;
    result = $(result)/<intro-check-hidden>$(check) ;
    local binutils-version = [ feature.get-values <binutils-version> : $(properties) ] ;
    result = $(result)/<binutils-version>unspecified ;
    result = $(result)/<binutils-version-hidden>$(binutils-version) ;
    local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
    result = $(result)/<gmp-version>unspecified ;
    result = $(result)/<gmp-version-hidden>$(gmp-version) ;
    local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
    result = $(result)/<mpfr-version>unspecified ;
    result = $(result)/<mpfr-version-hidden>$(mpfr-version) ;
    local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
    result = $(result)/<mpc-version>unspecified ;
    result = $(result)/<mpc-version-hidden>$(mpc-version) ;
  }
  else {
    result = <source>gcc.configure ;
  }
  return $(result) ;
}

make gcc.make
  : # Sources are introduced by the conditional requirements.
  : @make-gcc
  : <conditional>@make-gcc-req
  ;
explicit gcc.make ;

rule make-gcc ( targets * : sources * : properties * )
{
  local target = [ feature.get-values <intro-target> : $(properties) ] ;
  TARGET on $(targets) = $(target) ;
  local mingw32-cross = 0 ;
  if $(target) = x86_64-w64-mingw32 || $(target) = i686-w64-mingw32 {
    mingw32-cross = 1 ;
  }
  MINGW32_CROSS on $(targets) = $(mingw32-cross) ;
  PREFIX on $(targets) = [ feature.get-values <intro-prefix> : $(properties) ] ;
  STDOUT_ on $(targets) = [ feature.get-values <intro-stdout> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions make-gcc
{
  rm -f "$(<)" || exit $?
  [ ! -f "$(<[1]:D)/build/Makefile" ] && exit 1
  [ $(MINGW32_CROSS) -ne 0 ] \
    && { ln -sf "$(PREFIX)/$(TARGET)" "$(PREFIX)/mingw" || exit $?; }
  ( cd "$(<:D)/build" && make 1>>"$(STDOUT_)" 2>>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'make' for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
  ( cd "$(<:D)/build" && make install 1>>"$(STDOUT_)" 2>>"$(STDERR_)" ) \
    || { echo "ERROR: failed to 'make install' for the GCC build." 2>>"$(STDERR_)" 1>&2; exit 1; }
  [ $(MINGW32_CROSS) -ne 0 ] && { rm "$(PREFIX)/mingw" || exit $?; }
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


make gcc.test
  : gcc.make
  : @test-gcc
  ;
explicit gcc.test ;

rule test-gcc ( targets * : sources * : properties * )
{
  if ! $(sources[1]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  if $(sources[2]) {
    errors.error "ERROR: wrong number of sources." ;
  }
  COMMAND on $(targets) = $(INTRO_ROOT_DIR)/gcc/test.sh ;
  VERSION on $(targets) = [ feature.get-values <gcc-version> : $(properties) ] ;
  BUILD on $(targets) = [ feature.get-values <intro-build> : $(properties) ] ;
  HOST on $(targets) = [ feature.get-values <intro-host> : $(properties) ] ;
  TARGET on $(targets) = [ feature.get-values <intro-target : $(properties) ] ;
  PREFIX on $(targets) = [ feature.get-values <intro-prefix> : $(properties) ] ;
  CHECK on $(targets) = [ feature.get-values <intro-check> : $(properties) ] ;
  DEFAULT on $(targets) = [ feature.get-values <gcc-default> : $(properties) ] ;
  STDERR_ on $(targets) = [ feature.get-values <intro-stderr> : $(properties) ] ;
}
actions test-gcc
{
  rm -f "$(<)" || exit $?
  [ ! -f "$(>[1])" ] && exit 1
  ( "$(COMMAND)" $(VERSION) $(BUILD) $(HOST) $(TARGET) "$(PREFIX)" $(CHECK) $(DEFAULT) )
  if [ $? -ne 0 ]; then
    /bin/echo 'ERROR: post-installation test failed for the GCC build.' 2>>"$(STDERR_)" 1>&2
    exit 1
  fi
  [ -e "$(<)" ] && exit 1
  touch "$(<)"
}


rule install-req ( properties * )
{
  local result = <source>gcc.test ;

  local tmp = ;

  local version = [ feature.get-values <gcc-version> : $(properties) ] ;
  if $(version) = unspecified {
    errors.error "ERROR: the property '<gcc-version>' is not specified." ;
  }
  local binutils-version = [ feature.get-values <binutils-version> : $(properties) ] ;
  if $(binutils-version) = unspecified {
    binutils-version = [ feature.values <binutils-version> ] ;
    result = $(result)/<binutils-version>$(binutils-version[2]) ;
  }
  local gmp-version = [ feature.get-values <gmp-version> : $(properties) ] ;
  if $(gmp-version) = unspecified {
    gmp-version = [ feature.values <gmp-version> ] ;
    result = $(result)/<gmp-version>$(gmp-version[2]) ;
  }
  local mpfr-version = [ feature.get-values <mpfr-version> : $(properties) ] ;
  if $(mpfr-version) = unspecified {
    mpfr-version = [ feature.values <mpfr-version> ] ;
    result = $(result)/<mpfr-version>$(mpfr-version[2]) ;
  }
  local mpc-version = [ feature.get-values <mpc-version> : $(properties) ] ;
  if $(mpc-version) = unspecified {
    mpc-version = [ feature.values <mpc-version> ] ;
    result = $(result)/<mpc-version>$(mpc-version[2]) ;
  }

  local build = [ feature.get-values <intro-build> : $(properties) ] ;
  tmp = [ SHELL "\"$(INTRO_ROOT_DIR)/gcc/config.guess\" | tr --delete '\n'" ] ;
  if $(build) = unspecified {
    build = $(tmp) ;
  }
  if $(build) != $(tmp) {
    errors.error "ERROR: the property '<intro-build>$(build)' is not valid." ;
  }
  tmp = [ SHELL "\"$(INTRO_ROOT_DIR)/gcc/config.sub\" $(build) | tr --delete '\n'" ] ;
  if $(tmp) != $(build) {
    errors.error "ERROR: the property '<intro-build>$(build)' is not canonical." ;
  }
  result = $(result)/<intro-build>$(build) ;

  local host = [ feature.get-values <intro-host> : $(properties) ] ;
  if $(host) = unspecified {
    host = $(build) ;
  }
  tmp = [ SHELL "\"$(INTRO_ROOT_DIR)/gcc/config.sub\" $(host) | tr --delete '\n'" ] ;
  if $(tmp) != $(host) {
    errors.error "ERROR: the property '<intro-host>$(host)' is not canonical." ;
  }
  result = $(result)/<intro-host>$(host) ;

  local target = [ feature.get-values <intro-target> : $(properties) ] ;
  if $(target) = unspecified {
    target = $(host) ;
  }
  tmp = [ SHELL "\"$(INTRO_ROOT_DIR)/gcc/config.sub\" $(target) | tr --delete '\n'" ] ;
  if $(tmp) != $(target) {
    errors.error "ERROR: the property '<intro-target>$(target)' is not canonical." ;
  }
  result = $(result)/<intro-target>$(target) ;

  if $(target) = $(host) && $(host) = $(build) {
    local default_ = [ feature.get-values <gcc-default> : $(properties) ] ;
    if $(default_) = yes {
      errors.error "ERROR: self-host, self-target GCC should have a version suffix." ;
    }
  }

  if $(host) != $(build) && $(target) != $(host) {
    errors.error "ERROR: canadian cross is not supported." ;
  }

  local abi = [ feature.get-values <intro-abi> : $(properties) ] ;
  if $(abi) != unspecified {
    errors.error "ERROR: the property '<intro-abi>$(abi)' is not valid for the GCC build." ;
  }

  local link = [ feature.get-values <intro-link> : $(properties) ] ;
  if $(link) != unspecified {
    errors.error "ERROR: the property '<intro-link>$(link)' is not valid for the GCC build." ;
  }

  return $(result) ;
}

alias install
  : # The source 'gcc.test' is introduced by the following indirect conditional requirements.
  : <conditional>@install-req
  ;
explicit install ;
